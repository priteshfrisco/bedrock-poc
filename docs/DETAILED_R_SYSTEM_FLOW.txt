================================================================================
COMPLETE R SYSTEM FLOW - COMPREHENSIVE DOCUMENTATION
================================================================================
Document Purpose: Complete end-to-end breakdown of Nature's Way R-based 
                 supplement coding system
Created: December 28, 2025
Last Updated: December 28, 2025
Total Sections: 28
Total Lines: 5900+

Scope: 
  • Input files and data preparation
  • All 7 R coding scripts (Ingredient, Form, Age, Gender, Count, Size, Health Focus)
  • All business rules and post-processing logic
  • Manual analyst workflow and corrections
  • Complete column flow from raw Amazon data to final Master Item file

Audience: Technical team implementing new LLM-based coding system
================================================================================


================================================================================
TABLE OF CONTENTS
================================================================================

PART I: INPUT AND ARCHITECTURE (Lines 1-179)
---------------------------------------------
  Section 1:  Input Files
  Section 2:  Overall Processing Architecture

PART II: INGREDIENT DETECTION (Lines 180-1467)
-----------------------------------------------
  Section 3:  Script 1 - FI_CAT_Testing.R (Functional Ingredient Detection)
  Section 4:  Business Rules After Script 1
  Section 5:  State After Script 1 + Business Rules

PART III: PRODUCT ATTRIBUTES - FORM, AGE, GENDER (Lines 1468-3237)
-------------------------------------------------------------------
  Section 6:  Script 2 - Form Coding Final.R
  Section 7:  Business Rules After Script 2
  Section 8:  State After Script 2
  Section 9:  Script 3 - Age Coding Final.R
  Section 10: State After Script 3
  Section 11: Script 4 - Gender Coding Final.R
  Section 12: Business Rules Using Age + Gender
  Section 13: State After Scripts 2, 3, 4

PART IV: QUANTITY EXTRACTION (Lines 3238-4203)
-----------------------------------------------
  Section 14: Script 5 - Count Size Coding Final LB Update.R
  Section 15: Business Rules After Script 5
  Section 16: State After Script 5
  Section 17: Script 6 - Pack Size Final.R
  Section 18: Business Rule - Pack Size/Count QC
  Section 19: State After Scripts 5 & 6

PART V: HEALTH FOCUS AND TAXONOMY (Lines 4204-5023)
----------------------------------------------------
  Section 20: Script 7 - HF_JF1.R (Health Focus)
  Section 21: Business Rules After Script 7 (Extensive!)
  Section 22: State After Script 7 + Business Rules

PART VI: FINAL PROCESSING (Lines 5024-5449)
--------------------------------------------
  Section 23: Post-Processing - Organic Detection
  Section 24: Post-Processing - High Level Category
  Section 25: Final Cleanup and Output
  Section 26: Complete End-to-End Flow Summary

PART VII: MANUAL POST-PROCESSING (Lines 5450-5962)
---------------------------------------------------
  Section 27: Manual Post-Processing Workflow
  Section 28: Complete End-to-End Process Summary


KEY CONCEPTS EXPLAINED:
  • Random Forest ML Models (Form, Age, Gender prediction)
  • XGBoost ML Model (Health Focus prediction)
  • REGEX Pattern Matching (Count, Unit, Size extraction)
  • Lookup Table Hierarchies and Priority
  • Document-Term Matrix (DTM) for NLP
  • Business Rule Override Logic
  • 2022 Taxonomy Reorganization (Old → New mapping)
  • Manual Review Requirements and Time Estimates

================================================================================

================================================================================
SECTION 1: INPUT FILES
================================================================================

1.1 RAW AMAZON DATA INPUT
--------------------------
File: uncoded_amz_2025_p7.csv (or similar)

Columns (6 total):
1. ASIN/UPC Key         - Product identifier (ASIN)
2. MI: Brand            - Brand name
3. MI: Description      - Product title/description
4. Source Category Trx  - Not used
5. Source Subcategory Trx - Amazon's subcategory
6. Dollars in USD       - Not used

Example Row:
ASIN: "B0C3JD83X3"
Brand: "Nature's Way"
Description: "Nature's Way Turmeric Curcumin 500mg 60 Capsules"
Subcategory: "turmeric herbal supplements"


1.2 LOOKUP FILES (R System Data Folder)
----------------------------------------

A. TextReplaceingredient_Final.xlsx
   Sheet: "ingredient Lookup" (903 rows)
   Columns:
   - TextSearch: Keyword to search in title
   - TextReplace: Standardized name
   - SPINSfunctionalingredient: Functional ingredient value
   - Category: Category to assign
   - Subcategory: Subcategory to assign
   - Notes, done, group, type: Metadata

   Example:
   TextSearch: "turmeric" → Ingredient: "TURMERIC" → Category: "HERBAL REMEDIES" → Subcategory: "SINGLES"

B. NA_Test_for_FI.xlsx
   Sheet: "Alternate Coding" (571 rows)
   Columns:
   - Amazon SubCategory
   - NW Category
   - NW Subcategory
   
   Actions:
   - REMOVE: Filter out non-supplements
   - REMAP: Force assign category/subcategory
   - Not in table: Continue to ingredient detection

   Example:
   "bubble baths & soaks" → REMOVE
   "aloe vera herbal supplements" → REMAP → "HERBAL REMEDIES" / "NON-SPECIFIC"

C. herb_task.xlsx
   Sheet: "Herb List" (224 herbs)
   Purpose: Identify herbs for SINGLES vs FORMULAS logic
   
   Examples: TURMERIC, ECHINACEA, GOLDENSEAL, GINSENG, ASHWAGANDHA, etc.

D. hf_lookup.csv
   Purpose: Map Functional Ingredient → Default Health Focus
   Columns: Functional Ingredient | Focus
   
   Example:
   CALCIUM → BONE HEALTH
   CRANBERRY → URINARY TRACT HEALTH

E. MI Lookup.csv
   Purpose: Old taxonomy → New taxonomy transformations
   Applied in final post-processing


1.3 INITIAL DATA PREPARATION (FinalMerge.R Lines 64-93)
--------------------------------------------------------

Input: Raw CSV (6 columns)

Processing:
1. Read CSV: df_main <- read.csv(inputfilename)
2. Subset to needed columns: columns 1-3, 5 (SKU, Brand, Title, Subcategory)
3. Rename columns:
   - Column 1 → RetailerSku
   - Column 2 → Brand
   - Column 3 → Title
   - Column 4 → Subcategory1
4. Reorder: RetailerSku, Title, Brand, Subcategory1
5. Convert to lowercase:
   - df_test$Title <- tolower()
   - df_test$Brand <- tolower()
   - df_test$Subcategory1 <- tolower()

Output: df_test with 4 columns
- RetailerSku
- Title (lowercase)
- Brand (lowercase)
- Subcategory1 (lowercase)


================================================================================
SECTION 2: OVERALL PROCESSING ARCHITECTURE
================================================================================

2.1 HIGH-LEVEL FLOW
-------------------

Step 0: Data Preparation (df_test created)
         ↓
Step 1: Script 1 - FI_CAT_Testing.R (Functional Ingredient + Category/Subcategory)
         ↓
Step 2: Script 2 - Form Coding Final.R (Form)
         ↓
Step 3: Script 3 - Age Coding Final.R (Age)
         ↓
Step 4: Script 4 - Gender Coding Final.r (Gender)
         ↓
Step 5: Script 5 - Count Size Coding.R (Count, Unit)
         ↓
Step 6: Script 6 - Pack Size Final.R (Size)
         ↓
Step 7: Script 7 - HF_JF1.R (Health Focus)
         ↓
Step 8: Merge all outputs by RetailerSku
         ↓
Step 9: Apply 200+ business rules (FinalMerge.R)
         ↓
Step 10: Final cleanup and export (15 columns)


2.2 SCRIPT EXECUTION METHOD
----------------------------

All scripts are run sequentially by FinalMerge.R:

sourceEntireFolder <- function() { 
  files <- list.files("./ModelScripts", full.names=TRUE)
  files <- files[grepl("\\.[rR]$", files)]
  for (f in files) {
    source(f, local=FALSE, echo=FALSE)
  }
}

Each script:
- Reads from df_test (same input)
- Processes independently
- Creates output dataframe named "ItemsPredictOutput[Name]"

After all scripts finish:
- df_list <- mget(ls(pattern = "^ItemsPredictOutput"))
- new_items <- join_all(df_list, by = "RetailerSku")


2.3 COLUMN PRIORITY LOGIC
--------------------------

Multiple columns affect each other:

Category/Subcategory Determination:
1. Ingredient lookup (highest priority)
2. Amazon Subcategory REMAP (fallback)
3. NA (needs manual review)

Subcategory Refinement (happens AFTER all columns extracted):
1. Herb formula logic (herb count > 1 → FORMULAS)
2. Multivitamin logic (uses Age + Gender)
3. Protein form logic (uses Form)
4. Business rule overrides


================================================================================
SECTION 3: SCRIPT 1 - FI_CAT_Testing.R (FUNCTIONAL INGREDIENT DETECTION)
================================================================================

Purpose: Extract ingredients from title, assign Category/Subcategory
Input: df_test (4 columns)
Output: Functional Ingredient, other ing. 2-20, Category, Subcategory


3.1 STEP 1: AMAZON SUBCATEGORY FILTERING (Lines 13-36)
-------------------------------------------------------

Purpose: Remove non-supplements, store REMAP values

Code Logic:
```r
categ_check <- read_excel('NA_Test_for_FI.xlsx', sheet="Alternate Coding")

for (i in 1:nrow(df_test_FI2)){
  if (df_test_FI2$Subcategory1[i] %in% categ_check$`Amazon SubCategory`){
    df_test_FI2$Subcategory1_early[i] <- categ_check$`NW Subcategory`
  }
}

# Filter out REMOVE
df_test_FI3 <- df_test_FI2[!(df_test_FI2$Subcategory1_early == "REMOVE"),]
df_test_FI4 <- anti_join(df_test_FI2, df_test_FI3, by = "RetailerSku")
```

Outcomes:
A. Subcategory1 = "bubble baths & soaks"
   → Lookup: NW Subcategory = "REMOVE"
   → Product saved to df_test_FI4 (will be added back at end)
   → Will have Category = "REMOVE"

B. Subcategory1 = "aloe vera herbal supplements"
   → Lookup: NW Category = "HERBAL REMEDIES", NW Subcategory = "NON-SPECIFIC"
   → Subcategory1_early = "NON-SPECIFIC" (stored for fallback)
   → Product continues to ingredient detection

C. Subcategory1 = "some unknown category"
   → Not in lookup table
   → Product continues to ingredient detection
   → No fallback values


3.2 STEP 2: TEXT CLEANING (Lines 39-103)
-----------------------------------------

Purpose: Clean title for better ingredient matching

3.2A Load Lookup Tables:
```r
text_transform <- read_excel("TextReplaceingredient_Final.xlsx", sheet="ingredient Lookup")
# 903 rows: TextSearch | TextReplace | SPINSfunctionalingredient | Category | Subcategory

herb_task <- read_excel("herb_task.xlsx", sheet="Herb List")  
# 224 herbs

flavors <- read_excel("TextReplaceingredient_Final.xlsx", sheet="Flavors")
# Flavor names to ignore
```

3.2B Remove Problem Text:
```r
df_test_FI$Title <- gsub('b120','',df_test_FI$Title)       # Vitamin B120 → B12
df_test_FI$Title <- gsub('massage','',df_test_FI$Title)     # Remove massage
df_test_FI$Title <- gsub('dosage','',df_test_FI$Title)      # Remove dosage
df_test_FI$Title <- gsub('usage','',df_test_FI$Title)       # Remove usage
df_test_FI$Title <- gsub('[+]',' ',df_test_FI$Title)        # + → space
df_test_FI$Title <- str_replace_all(df_test_FI$Title, "\\*", " ")
df_test_FI$Title <- str_replace_all(df_test_FI$Title, "\\&", " ")
```

3.2C Brand Name Removal (Lines 74-102):
```r
# Load problem brands
protein_brand_to_check <- tolower(protein_df$`Problem Protein Brands`)
# Examples: "optimum nutrition", "isopure", "dymatize", etc.

brand_to_check <- c(new_problem_brands, protein_brand_to_check)

# Mark products with problem brands
df_test_FI$brand_check <- 0
df_test_FI[tolower(df_test_FI$Brand) %in% brand_to_check, 'brand_check'] <- 1

# Remove brand name from title
for(i in brand_to_check){
  df_test_FI[df_test_FI$brand_check==1,'Title'] <- 
    gsub(i,'',df_test_FI[df_test_FI$brand_check==1,'Title'])
}
```

Why Remove Brand Names?
- Prevents brand names from being detected as ingredients
- Example: "Optimum Nutrition Gold Standard Whey Protein"
  → After removal: "Gold Standard Whey Protein"
  → Can now correctly identify "Whey Protein" as ingredient


3.3 STEP 3: PREPARE TEXT TRANSFORMS & VITAMIN LOGIC (Lines 106-319)
--------------------------------------------------------------------

3.3A Prepare Ingredient Lookup (Lines 110-133):
```r
# Calculate search length
text_transform$SearchLength <- nchar(text_transform$TextSearch)

# Add spaces around short words (< 4 chars) to avoid partial matches
text_transform[SearchLength<4,]$TextSearch <- 
  paste0(' ', text_transform[SearchLength<4,]$TextSearch, ' ')

# Create variations with punctuation
text_transform_small$TextSearch with:
- Comma: " mg, "
- Period: " mg. "
- Parentheses: " (mg) "

# Append variations to lookup table
text_transform <- rbind(text_transform, text_transform_small, ...)
```

Why?
- "mg" should match " mg " not "dmg" or "omega"
- Handles "500 mg," vs "500 mg." vs "500 (mg)"

3.3B Separate Vitamin Ingredients (Lines 136-188):
```r
# Extract vitamin-related rows
text_transform$vitamin <- 0
for(i in 1:nrow(text_transform)){
  if(grepl('vitamin', text_transform$TextSearch[i]) || 
     grepl('vitamin', text_transform$TextReplace[i])){
    text_transform$vitamin[i] <- 1
  }
}
text_transform_vitamin <- text_transform[text_transform$vitamin==1,]

# Define vitamin types
vitamin_type <- c('a','b','b1','b-1','b2','b-2','b3','b-3','b5','b-5',
                  'b6','b-6','b12','b-12','c','d','d3','d-3','e','k',
                  'k2','k-2','k1','k-1','mk7','mk-7','adk','dak','a-d-k',
                  'd-a-k','b9','b-9')

# Map to ingredient names
vitamin_type_ing <- c('VITAMIN A','VITAMIN B','VITAMIN B1 (THIAMIN)',
                      'VITAMIN B2 (RIBOFLAVIN)','VITAMIN B3 (NIACIN)',
                      'VITAMIN B5 (PANTOTHENIC ACID)','VITAMIN B6 (PYRIDOXINE)',
                      'VITAMIN B12','VITAMIN C','VITAMIN D','VITAMIN D3',
                      'VITAMIN E','VITAMIN K','VITAMIN K2','VITAMIN K1',
                      'VITAMIN MK7','VITAMIN A - D - K','FOLIC ACID (FOLATE)')

# Create variations with punctuation
vitamin_type_comma1 <- paste0(',',vitamin_type,',')
vitamin_type_comma2 <- paste0(' ',vitamin_type,',')
vitamin_type_comma3 <- paste0(',',vitamin_type,' ')
vitamin_type_comma4 <- paste0(' ',vitamin_type,'.')
vitamin_type_comma5 <- paste0(' ',vitamin_type,')')
vitamin_type_comma6 <- paste0('(',vitamin_type,' ')
vitamin_type_comma7 <- paste0('(',vitamin_type,')')
vitamin_type_comma8 <- paste0(' ',vitamin_type,'-')
vitamin_type_comma9 <- paste0(' ',vitamin_type,' ')

# Combine all variations
vitamin_type <- c(vitamin_type_comma1, vitamin_type_comma2, ..., vitamin_type_comma9)
```

3.3C Define Vitamin Check Function (Lines 203-319):
```r
vitamin_check <- function(text_vitamin){
  vitamin_words <- c()
  vitamin_loc <- c()
  
  # Check specific vitamins first (most specific to least specific)
  
  # K12 check
  if(grepl('k 12|k-12|k12', text_vitamin)){
    vitamin_words <- c(vitamin_words, 'VITAMIN K12')
    vitamin_loc <- c(vitamin_loc, str_locate(text_vitamin, 'k')[1])
  }
  
  # D3 check
  if(grepl('d3|d-3', text_vitamin)){
    vitamin_words <- c(vitamin_words, 'VITAMIN D3')
    vitamin_loc <- c(vitamin_loc, str_locate(text_vitamin, 'd3')[1])
  }
  
  # B12 check
  if(grepl('b 12|b-12|b12', text_vitamin)){
    vitamin_words <- c(vitamin_words, 'VITAMIN B12')
    vitamin_loc <- c(vitamin_loc, str_locate(text_vitamin, 'b')[1])
  }
  
  # B-complex check
  if(grepl('b-complex|b complex|b energy complex|bcomplex', text_vitamin)){
    vitamin_words <- c(vitamin_words, 'VITAMIN B COMPLEX')
    vitamin_loc <- c(vitamin_loc, str_locate(text_vitamin, 'complex')[1])
  }
  
  # K-complex check
  if(grepl('k-complex|k complex', text_vitamin)){
    vitamin_words <- c(vitamin_words, 'VITAMIN K COMPLEX')
    vitamin_loc <- c(vitamin_loc, str_locate(text_vitamin, 'complex')[1])
  }
  
  # Named vitamins (thiamin, riboflavin, niacin, etc.)
  other_vitamin_type <- c('thiamin','riboflavin','niacin','pantothenic','pyridoxine','folic')
  other_vitamin_type_ing <- c('VITAMIN B1 (THIAMIN)','VITAMIN B2 (RIBOFLAVIN)',
                              'VITAMIN B3 (NIACIN)','VITAMIN B5 (PANTOTHENIC ACID)',
                              'VITAMIN B6 (PYRIDOXINE)','FOLIC ACID (FOLATE)')
  
  for(oth in 1:length(other_vitamin_type)){
    if(grepl(other_vitamin_type[oth], text_vitamin)){
      vitamin_words <- c(vitamin_words, other_vitamin_type_ing[oth])
      vitamin_loc <- c(vitamin_loc, str_locate(text_vitamin, other_vitamin_type[oth])[1])
    }
  }
  
  # Loop through all vitamin type variations
  for(w in vitamin_type){
    if(grepl(w, text_vitamin, fixed=TRUE)){
      vitamin_ing <- vitamin_type_ing[match(w, vitamin_type)]
      
      # Special handling for Vitamin E (Ester-E)
      if(vitamin_ing=='VITAMIN E' && grepl('ester', text_vitamin)){
        vitamin_ing <- 'VITAMIN E (ESTER-E)'
      }
      
      # Special handling for Vitamin C (Ester-C)
      if(vitamin_ing=='VITAMIN C' && grepl('ester', text_vitamin)){
        vitamin_ing <- 'VITAMIN C (ESTER-C ONLY)'
      }
      
      vitamin_words <- c(vitamin_words, vitamin_ing)
      vitamin_loc <- c(vitamin_loc, str_locate(text_vitamin, w)[1])
    }
  }
  
  # Multivitamin check
  if(grepl('multivitamin|multi vitamin|multi-vitamin|multivite|multi vite|daily multi|complete multi', text_vitamin)){
    vitamin_words <- c(vitamin_words, 'Multiple Vitamin')
    vitamin_loc <- c(vitamin_loc, str_locate(text_vitamin, 'multi')[1])
  }
  
  # Gummy Vites (brand-specific multivitamin)
  if(grepl('gummy vites', text_vitamin)){
    vitamin_words <- c(vitamin_words, 'Multiple Vitamin')
    vitamin_loc <- c(vitamin_loc, str_locate(text_vitamin, 'gummy')[1])
  }
  
  # Alive Once Daily (brand-specific multivitamin)
  if(grepl('alive once daily', text_vitamin)){
    vitamin_words <- c(vitamin_words, 'Multiple Vitamin')
    vitamin_loc <- c(vitamin_loc, str_locate(text_vitamin, 'alive')[1])
  }
  
  # Create output dataframe
  words_df <- data.frame('words'=vitamin_words, 'loc'=vitamin_loc)
  words_df <- words_df[!duplicated(words_df$words),]  # Remove duplicates
  
  return(words_df)
}
```

Example:
Title: "vitamin d3 with k2"
→ vitamin_check() returns:
  words: ["VITAMIN D3", "VITAMIN K2"]
  loc: [0, 15]


3.4 STEP 4: CONDITIONAL INGREDIENT DETECTION (Lines 323-735)
-------------------------------------------------------------

Purpose: Handle special ingredients with complex logic

Define condition_func() - Returns special ingredients found:

```r
condition_func <- function(text_condition){
  ingredients <- c()
  ingredients_loc <- c()
  
  # [Detailed logic for each special ingredient type below]
  
  return(data.frame('words'=ingredients, 'loc'=ingredients_loc))
}
```

3.4A ALGAE Detection (Lines 336-358):
```r
cond_algae <- 0

if(grepl('spirulina', text_condition)){
  ingredients <- c(ingredients, 'Spirulina Blue Green Algae')
  loc <- str_locate(text_condition, 'spirulina')[1]
  ingredients_loc <- c(ingredients_loc, loc)
  cond_algae <- 1
}

if(grepl('chlorophyll|chlorella', text_condition)){
  ingredients <- c(ingredients, 'Chlorophyll / Chlorella')
  loc <- min(str_locate(text_condition, 'chlorophyll')[1],
             str_locate(text_condition, 'chlorella')[1], na.rm=TRUE)
  ingredients_loc <- c(ingredients_loc, loc)
  cond_algae <- 1
}

if((grepl('algae', text_condition) || grepl('klamath', text_condition)) && cond_algae==0){
  ingredients <- c(ingredients, 'Algae - Other')
  loc <- min(str_locate(text_condition, 'algae')[1],
             str_locate(text_condition, 'klamath')[1], na.rm=TRUE)
  ingredients_loc <- c(ingredients_loc, loc)
}
```

Logic:
- Spirulina → "Spirulina Blue Green Algae"
- Chlorophyll/Chlorella → "Chlorophyll / Chlorella"
- Any other algae mention → "Algae - Other"

3.4B CALCIUM Detection (Lines 441-473):
```r
calcium_subs <- c('coral calcium',
                  'calcium & magnesium','calcium and magnesium','calcium/magnesium',
                  'calcium d-glucarate','calcium d glucarate')

calcium_subs_ing <- c('CORAL CALCIUM',
                      rep('CALCIUM/MAGNESIUM COMBINATIONS',3),
                      rep('CALCIUM D-GLUCARATE',2))

if(grepl('calcium', text_condition)){
  loc_calc <- str_locate(text_condition, 'calcium')[1]
  string_check_calc <- substr(text_condition, loc_calc-10, loc_calc+30)
  
  calcium_subs_found <- 0
  for(cs in 1:length(calcium_subs)){
    if(grepl(calcium_subs[cs], string_check_calc)){
      calcium_subs_found <- 1
      if(calcium_subs_ing[cs] %!in% ingredients){
        ingredients <- c(ingredients, calcium_subs_ing[cs])
        ingredients_loc <- c(ingredients_loc, loc_calc)
      }
    }
  }
  
  if(calcium_subs_found==0){
    ingredients <- c(ingredients, 'CALCIUM')
    ingredients_loc <- c(ingredients_loc, loc_calc)
  }
}

if(grepl('calmag|cal mag|cal/mag', text_condition)){
  if('CALCIUM/MAGNESIUM COMBINATIONS' %!in% ingredients){
    ingredients <- c(ingredients, 'CALCIUM/MAGNESIUM COMBINATIONS')
    ingredients_loc <- c(ingredients_loc, str_locate(text_condition, 'cal')[1])
  }
}
```

Logic:
- Check for specific calcium types first (coral, cal-mag, d-glucarate)
- If none found, assign generic "CALCIUM"

3.4C PROTEIN Detection (Lines 619-731) - MOST COMPLEX:
```r
# Replace meat terms with generic "meat"
meat_terms <- c('fish','chicken','beef')
for(mt in meat_terms){
  text_condition <- gsub(mt, 'meat', text_condition)
}

protein_found <- 'not'
pair_detected <- 0
combo_detected <- 0

# Define protein types
check_addon_animal <- c('casein','egg','insect','meat','milk','whey')
check_addon_plant <- c('pea','rice','soy','alfalfa','baobab')

# Count animal and plant proteins
check_comm_length_animal <- 0
check_comm_length_plant <- 0

for(p_a in check_addon_animal){
  if(grepl(p_a, text_condition)){
    check_comm_length_animal <- check_comm_length_animal + 1
  }
}

for(p_p in check_addon_plant){
  if(grepl(p_p, text_condition)){
    check_comm_length_plant <- check_comm_length_plant + 1
  }
}

# Find first protein mention
loc_protein <- 1000
for(c in c('protein', check_addon_plant, check_addon_animal)){
  if(grepl(c, text_condition)){
    loc_protein <- min(loc_protein, str_locate(text_condition, c)[1])
  }
}

# LOGIC: Determine protein type

if(grepl('protein', text_condition)){
  
  # Case 1: Both plant AND animal
  if(check_comm_length_plant > 0 && check_comm_length_animal > 0){
    combo_detected <- 1
    protein_found <- 'Protein - Animal & Plant Combo'
  }
}

if(grepl('protein', text_condition) && combo_detected==0){
  
  # Case 2: Multiple plant proteins
  if(check_comm_length_plant > 1){
    protein_found <- 'Protein - Plant - Multi'
  }
  
  # Case 3: Plant keyword with no specific plant
  if((grepl('plant', text_condition) || grepl('vegan', text_condition)) && 
     check_comm_length_plant==0){
    protein_found <- 'Protein - Plant - General'
  }
  
  # Case 4: Single plant protein
  if(check_comm_length_plant==1){
    if(grepl('rice', text_condition)){
      protein_found <- 'Protein - Plant - Rice'
    } else if(grepl('soy', text_condition)){
      protein_found <- 'Protein - Plant - Soy'
    } else if(grepl('pea', text_condition)){
      protein_found <- 'Protein - Plant - Pea'
    } else {
      protein_found <- 'Protein - Plant - General'
    }
  }
}

if(grepl('protein', text_condition) && combo_detected==0 && protein_found=='not'){
  
  # Case 5: No animal proteins mentioned
  if(check_comm_length_animal==0){
    protein_found <- 'Protein - Animal - General'
  }
  
  # Case 6: Two animal proteins (check for common pairs)
  else if(check_comm_length_animal==2){
    if(grepl('milk', text_condition) && grepl('egg', text_condition)){
      protein_found <- 'Protein - Animal - Milk & Egg'
      pair_detected <- 1
    }
    else if(grepl('whey', text_condition) && grepl('casein', text_condition)){
      protein_found <- 'Protein - Animal - Whey & Casein'
      pair_detected <- 1
    }
    else if(grepl('whey', text_condition) && grepl('milk', text_condition)){
      protein_found <- 'Protein - Animal - Whey & Milk'
      pair_detected <- 1
    }
    else if(grepl('whey', text_condition) && grepl('egg', text_condition)){
      protein_found <- 'Protein - Animal - Whey & Egg'
      pair_detected <- 1
    }
    
    if(pair_detected==0){
      protein_found <- 'Protein - Animal - Multi'
    }
  }
  
  # Case 7: More than 2 animal proteins
  else if(check_comm_length_animal > 2){
    protein_found <- 'Protein - Animal - Multi'
  }
  
  # Case 8: Single animal protein
  else if(check_comm_length_animal==1){
    if(grepl('casein', text_condition)){
      protein_found <- 'Protein - Animal - Casein'
    } else if(grepl('egg', text_condition)){
      protein_found <- 'Protein - Animal - Egg'
    } else if(grepl('insect', text_condition)){
      protein_found <- 'Protein - Animal - Insect'
    } else if(grepl('meat', text_condition)){
      protein_found <- 'Protein - Animal - Meat'
    } else if(grepl('whey', text_condition)){
      protein_found <- 'Protein - Animal - Whey'
    } else if(grepl('milk', text_condition)){
      protein_found <- 'Protein - Animal - Milk'
    }
  }
}

# Add to ingredients list if found
if(protein_found != 'not'){
  ingredients <- c(ingredients, protein_found)
  ingredients_loc <- c(ingredients_loc, loc_protein)
}
```

Protein Detection Logic Summary:
1. Count plant proteins (pea, rice, soy, alfalfa, baobab)
2. Count animal proteins (casein, egg, insect, meat, milk, whey)
3. If both plant AND animal → "Protein - Animal & Plant Combo"
4. If multiple plant → "Protein - Plant - Multi"
5. If single plant → "Protein - Plant - [Pea/Rice/Soy/General]"
6. If multiple animal → check for common pairs (Whey & Casein, Milk & Egg, etc.)
7. If pair found → "Protein - Animal - Whey & Casein" (etc.)
8. If no pair → "Protein - Animal - Multi"
9. If single animal → "Protein - Animal - [Whey/Casein/Egg/etc.]"

3.4D OTHER SPECIAL CASES:
```r
# Dong Quai vs Angelica (Lines 360-372)
if(grepl('angelica', text)){
  if(grepl('dong quai', text)){
    ingredients <- c(ingredients, 'DONG QUAI')
  } else {
    ingredients <- c(ingredients, 'ANGELICA')
  }
}

# Arnica - Homeopathic vs Herbal (Lines 374-385)
if(grepl('arnica', text)){
  if(grepl('homeopath', text)){
    ingredients <- c(ingredients, 'ARNICA (HOMEOPATHIC)')
  } else {
    ingredients <- c(ingredients, 'ARNICA (HERBAL)')
  }
}

# Basil vs Holy Basil (Lines 387-398)
if(grepl('basil', text)){
  loc_basil <- str_locate(text, 'basil')[1]
  string_check_basil <- substr(text, loc_basil-10, loc_basil)
  if(grepl('holy', string_check_basil)){
    ingredients <- c(ingredients, 'Holy Basil')
  } else {
    ingredients <- c(ingredients, 'Basil (Not Culinary Not Holy)')
  }
}

# Beta Carotene (Lines 401-406)
if(grepl('beta carotene|beta-carotene', text)){
  ingredients <- c(ingredients, 'Beta Carotene (Not Combo)')
}

# SAM-E (Lines 422-439)
if(grepl('methionine', text)){
  if(grepl('s-adenosyl', text)){
    ingredients <- c(ingredients, 'SAM E')
  } else {
    ingredients <- c(ingredients, 'METHIONINE')
  }
} else {
  if(grepl('sam-e| sam e', text)){
    ingredients <- c(ingredients, 'SAM E')
  }
}

# Choline + Inositol (Lines 529-540)
if(grepl('choline', text)){
  if(grepl('inositol', text)){
    ingredients <- c(ingredients, 'Choline and Inositol (Combo)')
  } else {
    ingredients <- c(ingredients, 'Choline')
  }
}

# Ubiquinol (Lines 542-547)
if(grepl('ubiquinol', text)){
  ingredients <- c(ingredients, 'Co-Enzyme Q 10 - Ubiquinol')
}

# Echinacea + Goldenseal Combo (Lines 549-554)
if(grepl('echinacea', text) && grepl('goldenseal', text)){
  ingredients <- c(ingredients, 'echinacea goldenseal combo')
}

# Glandular (Lines 556-561)
if(grepl('glandular', text)){
  ingredients <- c(ingredients, 'Glandular')
}

# Glucosamine + Chondroitin (Lines 563-568)
if(grepl('gluclosamine', text) && grepl('chondroitin', text)){
  ingredients <- c(ingredients, 'Glucosamine Chondroitin Combo')
}

# Caffeine (check for "caffeine-free") (Lines 475-483)
if(grepl('caffein', text) && 
   !(grepl('non caffeinated|non-caffeinated|de-caffeinated|decaffeinated|without caffeine', text))){
  loc_caffein <- str_locate(text, 'caffein')[1]
  text_sub <- substr(text, loc_caffein-20, loc_caffein+20)
  if(!grepl('free', text_sub)){
    ingredients <- c(ingredients, 'Caffeine')
  }
}

# Gluten (check for "gluten-free") (Lines 486-494)
if(grepl('gluten', text) && 
   !(grepl('no-gluten|no gluten|non gluten|non-gluten|digest', text))){
  loc_gluten <- str_locate(text, 'gluten')[1]
  text_sub <- substr(text, loc_gluten-20, loc_gluten+20)
  if(!grepl('free', text_sub)){
    ingredients <- c(ingredients, 'GLUTEN PRODUCT')
  }
}

# Gelatin (check for "gelatin-free") (Lines 496-504)
if(grepl('gelatin', text) && 
   !(grepl('no-gelatin|non gelatin|non-gelatin|no gelatin', text))){
  loc_gelatin <- str_locate(text, 'gelatin')[1]
  text_sub <- substr(text, loc_gelatin-20, loc_gelatin+20)
  if(!grepl('free', text_sub)){
    ingredients <- c(ingredients, 'GELATIN SUPPLEMENTS')
  }
}

# Aspirin (check for "aspirin-free") (Lines 579-584)
if(grepl('aspirin', text) && 
   !(grepl('aspirin-free|aspirin free|no-aspirin|no aspirin', text))){
  ingredients <- c(ingredients, 'ASPIRIN')
}

# Menthol (Lines 587-592)
if(grepl('menthol', text)){
  ingredients <- c(ingredients, 'MENTHOL')
}

# Mushroom (Lines 603-610)
if(grepl('mushroom', text) && 
   !(grepl('chaga', text) && grepl('cordycep', text) && 
     grepl('maitake', text) && grepl('reishi', text) && 
     grepl('shiitake', text))){
  ingredients <- c(ingredients, 'MUSHROOMS - OTHER')
}
```


3.5 STEP 5: MAIN INGREDIENT EXTRACTION LOOP (Lines 792-833)
------------------------------------------------------------

Purpose: Extract ALL ingredients from each product

```r
# Create empty matrix for up to 20 ingredients per product
final_mat <- matrix(data=NA, nrow=nrow(df_test_FI), ncol=20)

# Loop through each product
for(i in 1:nrow(df_test_FI)){
  
  # Get conditional ingredients (protein, algae, calcium, vitamins, etc.)
  conditional_words <- condition_func(df_test_FI$Title[i])
  
  # Get vitamin ingredients
  vitamin_words <- vitamin_check(df_test_FI$Title[i])
  
  # Search through standard ingredient lookup
  word_found <- c()
  word_loc <- c()
  
  for(j in 1:nrow(text_transform)){
    text_a <- text_transform$TextSearch[j]
    text_a_ing <- text_transform$SPINSfunctionalingredient[j]
    
    if(grepl(text_a, df_test_FI$Title[i], fixed=TRUE)){
      
      # Check if it's a flavor (skip if near "flavor" keyword)
      if(text_a %in% flavors_list && grepl('flavor', df_test_FI$Title[i], fixed=TRUE)){
        text_a_locs <- str_locate_all(df_test_FI$Title[i], text_a)[[1]][,1]
        flavor_loc <- str_locate(df_test_FI$Title[i], 'flavor')[[1]][1]
        min_dist <- min(abs(text_a_locs - flavor_loc))
        if(min_dist < 25){
          next()  # Skip - it's a flavor mention
        }
      }
      
      # Found ingredient!
      text_loc <- str_locate(df_test_FI$Title[i], text_a)[1]
      word_found <- c(word_found, text_a_ing)
      word_loc <- c(word_loc, text_loc)
    }
  }
  
  # Combine all found ingredients
  words_df <- data.frame('words'=word_found, 'loc'=word_loc)
  df_final <- rbind(conditional_words, words_df, vitamin_words)
  
  if(nrow(df_final) > 0){
    # Sort by position (first found = primary)
    df_final <- df_final[order(df_final$loc, decreasing=FALSE),]
    
    # Remove duplicate ingredients
    df_final <- df_final[!duplicated(df_final$words),]
    
    # Apply ingredient_final_check() for special combos
    ingredient_final <- ingredient_final_check(df_final$words)
    
    # Store in matrix
    final_mat[i, 1:length(ingredient_final)] <- ingredient_final
  }
}
```

Ingredient Priority:
1. Position in title (first mentioned = primary)
2. Duplicates removed
3. Special combos checked

Example:
Title: "vitamin d3 with calcium and magnesium"
→ Found: ["VITAMIN D", "CALCIUM", "MAGNESIUM"] at positions [0, 15, 30]
→ Primary ingredient = "VITAMIN D" (first)
→ other ing. 2 = "CALCIUM"
→ other ing. 3 = "MAGNESIUM"


3.6 STEP 6: INGREDIENT FINAL CHECK - COMBO DETECTION (Lines 743-783)
---------------------------------------------------------------------

Purpose: Handle special ingredient combinations

```r
ingredient_final_check <- function(ingredient_list){
  
  # Herbal Cold & Flu singles vs formulas
  if(length(ingredient_list)==1){
    if(ingredient_list==c('Herbal Formulas Cold & Flu')){
      ingredient_list <- c('Herbal Singles Cold & Flu')
    }
  }
  
  # Glucosamine + Chondroitin Combo
  if('GLUCOSAMINE' %in% ingredient_list && 'CHONDROITIN' %in% ingredient_list){
    ingredient_list[which(ingredient_list=='GLUCOSAMINE')] <- 'GLUCOSAMINE CHONDROITIN COMBO'
    ingredient_list <- ingredient_list[ingredient_list!='CHONDROITIN']  # Remove standalone
  }
  
  # Vitamin B1+B2+B6+B12 Combo
  vitaminb1_2_6_12 <- c('VITAMIN B1 (THIAMIN)','VITAMIN B2 (RIBOFLAVIN)',
                        'VITAMIN B6 (PYRIDOXINE)','VITAMIN B12')
  if(all(vitaminb1_2_6_12 %in% ingredient_list)){
    rest_vitamin <- setdiff(ingredient_list, vitaminb1_2_6_12)
    check_rest_vitamin <- grepl('VITAMIN', rest_vitamin)
    if(sum(check_rest_vitamin)==0){  # No other vitamins
      ingredient_list[which(ingredient_list=='VITAMIN B1 (THIAMIN)')] <- 'VITAMIN B1 - B2 - B6 - B12'
      ingredient_list <- setdiff(ingredient_list, vitaminb1_2_6_12[2:4])
    }
  }
  
  # Vitamin A + D Combo
  vitamin_a_d <- c('VITAMIN A','VITAMIN D')
  if(all(vitamin_a_d %in% ingredient_list)){
    rest_vitamin <- setdiff(ingredient_list, vitamin_a_d)
    check_rest_vitamin <- grepl('VITAMIN', rest_vitamin)
    if(sum(check_rest_vitamin)==0){  # No other vitamins
      ingredient_list[which(ingredient_list=='VITAMIN A')] <- 'VITAMIN A & D COMBO'
      ingredient_list <- setdiff(ingredient_list, vitamin_a_d[2])
    }
  }
  
  # Multiple Vitamin should be first (primary)
  if('Multiple Vitamin' %in% ingredient_list){
    mulitivitamin_pos <- which(ingredient_list=='Multiple Vitamin')
    ingredient_list <- c(ingredient_list[mulitivitamin_pos], 
                        ingredient_list[ingredient_list %!in% ingredient_list[mulitivitamin_pos]])
  }
  
  return(ingredient_list)
}
```

Logic:
- If Glucosamine AND Chondroitin found → Merge to combo, remove individual
- If B1+B2+B6+B12 all found (and no other vitamins) → Merge to combo
- If Vitamin A + D found (and no other vitamins) → Merge to combo
- If Multiple Vitamin found → Move to first position (primary)


3.7 STEP 7: MAP INGREDIENT → CATEGORY/SUBCATEGORY (Lines 836-863)
-------------------------------------------------------------------

Purpose: Assign Category and Subcategory based on primary ingredient

```r
# Convert matrix to dataframe
final_mat <- data.frame(final_mat)
final_mat <- final_mat[colSums(!is.na(final_mat)) > 0]  # Remove empty columns

# Name columns
colnames(final_mat) <- c('Primary ingredient', paste0('other ing. ', 2:ncol(final_mat)))

# Add to main dataframe
df_test_FI <- cbind(df_test_FI, final_mat)

# Prepare lookup subset (Ingredient → Category/Subcategory)
text_transform_sub <- text_transform_main[,c('SPINSfunctionalingredient','Category','Subcategory')]
colnames(text_transform_sub)[1] <- 'Primary ingredient'

# Merge to get Category/Subcategory
result_df <- merge(x=df_test_FI, y=text_transform_sub, by='Primary ingredient', all.x=TRUE)

# Remove duplicates
result_df <- result_df[!duplicated(result_df),]

# Handle non-NA cases
result_df_non_na <- result_df[!is.na(result_df$Category),]

# Handle NA cases (use Function_Replace sheet as fallback)
result_df_na <- result_df[is.na(result_df$Category),]
result_df_na <- merge(x=result_df_na, y=function_replace, by='Primary ingredient', all.x=TRUE)

# Combine back
result_df_final <- rbind(result_df_non_na, result_df_na)

# Vitamin overrides
result_df_final[grepl('VITAMIN', result_df_final$`Primary ingredient`),]$Category <- 
  'BASIC VITAMINS & MINERALS'
result_df_final[grepl('VITAMIN', result_df_final$`Primary ingredient`),]$Subcategory <- 
  'BASIC VITAMINS & MINERALS'

# Multiple Vitamin override
result_df_final[result_df_final$`Primary ingredient` %in% c('Multiple Vitamin'),]$Category <- 
  'COMBINED MULTIVITAMINS'
result_df_final[result_df_final$`Primary ingredient` %in% c('Multiple Vitamin'),]$Subcategory <- 
  'COMBINED MULTIVITAMINS'
```

Example:
Primary ingredient = "TURMERIC"
→ Lookup in text_transform_sub:
→ Category = "HERBAL REMEDIES"
→ Subcategory = "SINGLES" (default, may be changed by herb logic)


3.8 STEP 8: HERB FORMULA LOGIC (Lines 866-929)
-----------------------------------------------

Purpose: Determine if herbal product is SINGLES or FORMULAS

```r
# Load herb list
herb_list <- herb_task$`Herb List`  # 224 herbs

# Get all ingredient column names
ing_colnames <- colnames(result_df_final)[grepl('ing', colnames(result_df_final))]

for (i in 1:nrow(result_df_final)){
  
  # Special case: Chia Seed vs Chia Seed Oil
  if(!is.na(result_df_final$`Primary ingredient`[i]) && 
     result_df_final$`Primary ingredient`[i]=='CHIA SEED OR OIL'){
    if(grepl('chia seed oil', result_df_final$Title[i])){
      result_df_final$Category[i] <- 'OIL CATEGORY'
    } else {
      result_df_final$Category[i] <- 'HERBAL REMEDIES'
    }
  }
  
  # Get all ingredients for this product
  ing_found <- as.vector(t(result_df_final[i, ing_colnames])[,1])
  
  # Special case: MENTHOL
  if(result_df_final$`Primary ingredient`[i]=='MENTHOL' && 
     !is.na(result_df_final$`Primary ingredient`[i])){
    result_df_final$Category[i] <- 'HERBAL/HOMEOPATHIC COLD & FLU'
    if(length(ing_found)==1){
      result_df_final$Subcategory[i] <- 'HERBAL SINGLES COLD & FLU'
    } else {
      result_df_final$Subcategory[i] <- 'HERBAL FORMULAS COLD & FLU'
    }
  }
  
  # Special case: BLACK CURRANT OIL
  if(result_df_final$`Primary ingredient`[i]=='BLACK CURRANT OIL' && 
     !is.na(result_df_final$`Primary ingredient`[i])){
    if(grepl('black currant oil|black currant seed oil', result_df_final$Title[i])){
      result_df_final$Category[i] <- 'OIL CATEGORY'
      result_df_final$Subcategory[i] <- 'ALL OTHER OIL'
    } else {
      result_df_final$Category[i] <- 'HERBAL REMEDIES'
      result_df_final$Subcategory[i] <- 'SINGLES'
    }
  }
  
  # MAIN HERB LOGIC: If Category = HERBAL REMEDIES
  if(!is.na(result_df_final$Category[i]) && 
     result_df_final$Category[i]=='HERBAL REMEDIES'){
    
    # Skip YOHIMBE (special case)
    if(result_df_final$`Primary ingredient`[i]=='YOHIMBE'){
      next()
    }
    
    # Skip POLYPHENOLS and FOOD SUPPLEMENTS (already correctly categorized)
    if((result_df_final$Subcategory[i]=='POLYPHENOLS' && !is.na(result_df_final$Subcategory[i])) || 
       (result_df_final$Subcategory[i]=='FOOD SUPPLEMENTS' && !is.na(result_df_final$Subcategory[i]))){
      next()
    }
    
    # Count herbs in ingredient list
    herb_found <- intersect(ing_found, herb_list)
    
    if(length(herb_found) > 1){
      result_df_final$Subcategory[i] <- 'FORMULAS'
    } else if(length(herb_found) == 1){
      result_df_final$Subcategory[i] <- 'SINGLES'
    }
  }
  
  # Fallback: If Primary ingredient = NA, use Amazon Subcategory REMAP
  if(is.na(result_df_final$`Primary ingredient`[i])){
    if(result_df_final$Subcategory1[i] %in% categ_check$`Amazon SubCategory`){
      categ_check_sub <- categ_check[categ_check$`Amazon SubCategory`==result_df_final$Subcategory1[i],]
      result_df_final$Category[i] <- categ_check_sub$`NW Category`
      result_df_final$Subcategory[i] <- categ_check_sub$`NW Subcategory`
    }
  }
}
```

Example 1 - Single Herb:
Primary ingredient = "TURMERIC"
other ing. 2 = NA
→ herb_found = ["TURMERIC"]
→ herb count = 1
→ Subcategory = "SINGLES"

Example 2 - Herb Formula:
Primary ingredient = "ECHINACEA"
other ing. 2 = "GOLDENSEAL"
other ing. 3 = "GINGER"
→ herb_found = ["ECHINACEA", "GOLDENSEAL", "GINGER"]
→ herb count = 3
→ Subcategory = "FORMULAS"

Example 3 - Herb + Non-Herb:
Primary ingredient = "ECHINACEA"
other ing. 2 = "VITAMIN C"
→ herb_found = ["ECHINACEA"]
→ herb count = 1
→ Subcategory = "SINGLES"


3.9 STEP 9: ADD REMOVE PRODUCTS BACK (Lines 931-957)
-----------------------------------------------------

Purpose: Add filtered-out products back with Category = "REMOVE"

```r
# Clean up output
result_df_final <- result_df_final[, !(colnames(result_df_final) %in% c("Subcategory1", "brand_check"))]

# Rename for consistency
XItemsPredictOutputFuncCat <- result_df_final
XItemsPredictOutputFuncCat <- XItemsPredictOutputFuncCat %>% distinct(RetailerSku, .keep_all=TRUE)

# Remember df_test_FI4 (filtered out products from Step 1)?
df_test_FI4 <- df_test_FI4[,-c(2:4)]  # Remove Brand, Title, Subcategory1
df_test_FI4$Category <- "REMOVE"
names(df_test_FI4)[2] <- "Subcategory"
df_test_FI4$`Primary ingredient` <- NA
df_test_FI4 <- df_test_FI4[,c(1,4,3,2)]  # Reorder

# Create final output
ItemsPredictOutputFuncCatFinal <- subset(XItemsPredictOutputFuncCat, 
                                         select=c("RetailerSku", "Primary ingredient", 
                                                 "Category", "Subcategory"))

# Add REMOVE products back
ItemsPredictOutputFuncCatFinal <- rbind(ItemsPredictOutputFuncCatFinal, df_test_FI4)
```

Result:
- Products with Category = "REMOVE" are included in output
- Will be filtered out in final export


3.10 SCRIPT 1 OUTPUT
--------------------

Output Dataframe: ItemsPredictOutputFuncCatFinal

Columns:
- RetailerSku
- Primary ingredient
- other ing. 2 (optional, if multiple ingredients found)
- other ing. 3 (optional)
- ... (up to 20 ingredient columns)
- Category
- Subcategory

Example Outputs:

Row 1 - Single Herb:
RetailerSku: "B0001"
Primary ingredient: "TURMERIC"
other ing. 2: NA
Category: "HERBAL REMEDIES"
Subcategory: "SINGLES"

Row 2 - Herb Formula:
RetailerSku: "B0002"
Primary ingredient: "ECHINACEA"
other ing. 2: "GOLDENSEAL"
other ing. 3: "GINGER"
Category: "HERBAL/HOMEOPATHIC COLD & FLU"
Subcategory: "HERBAL FORMULAS COLD & FLU"

Row 3 - Protein:
RetailerSku: "B0003"
Primary ingredient: "PROTEIN - ANIMAL - WHEY"
other ing. 2: NA
Category: "ACTIVE NUTRITION"
Subcategory: "PROTEIN & MEAL REPLACEMENTS"

Row 4 - Multivitamin:
RetailerSku: "B0004"
Primary ingredient: "Multiple Vitamin"
other ing. 2: NA
Category: "COMBINED MULTIVITAMINS"
Subcategory: "COMBINED MULTIVITAMINS"

Row 5 - Filtered Out:
RetailerSku: "B0005"
Primary ingredient: NA
Category: "REMOVE"
Subcategory: "REMOVE"


================================================================================
SECTION 4: BUSINESS RULES AFTER SCRIPT 1 (FinalMerge.R Lines 150-228)
================================================================================

Purpose: Override Script 1's Category/Subcategory based on business requirements

After all scripts finish and merge, these rules run:


4.1 RULE 1: PROTEIN OVERRIDES (Lines 152-180)
----------------------------------------------

Purpose: Force all protein products into ACTIVE NUTRITION category

```r
protein_ingredients = c('PROTEIN - ANIMAL - CASEIN',
                        'PROTEIN - ANIMAL - MILK',
                        'PROTEIN - ANIMAL - EGG',
                        'PROTEIN - ANIMAL - GENERAL',
                        'PROTEIN - ANIMAL - INSECT',
                        'PROTEIN - ANIMAL - MEAT',
                        'PROTEIN - ANIMAL - MILK & EGG',
                        'PROTEIN - ANIMAL - MULTI',
                        'PROTEIN - ANIMAL - WHEY',
                        'PROTEIN - ANIMAL - WHEY & CASEIN',
                        'PROTEIN - ANIMAL - WHEY & EGG',
                        'PROTEIN - ANIMAL - WHEY & MILK',
                        'PROTEIN - ANIMAL & PLANT COMBO',
                        'PROTEIN - PLANT - GENERAL',
                        'PROTEIN - PLANT - MULTI',
                        'PROTEIN - PLANT - PEA',
                        'PROTEIN - PLANT - RICE')

for (i in 1:nrow(new_items)){
  if(new_items$`Primary ingredient`[i] %in% protein_ingredients && 
     !is.na(new_items$`Primary ingredient`[i])){
    new_items$Category[i] <- "ACTIVE NUTRITION"
    new_items$Subcategory[i] <- "PROTEIN & MEAL REPLACEMENTS"  # Will be split later by form
  }
}
```

Why:
- Script 1 might assign different categories based on ingredient lookup
- Business wants ALL protein in one category
- Subcategory will be refined later based on Form (powder vs bar)

Before: Category could be "AMINO ACIDS" or various others
After: Category = "ACTIVE NUTRITION", Subcategory = "PROTEIN & MEAL REPLACEMENTS"


4.2 RULE 2: SAM-E OVERRIDE (Lines 176-179)
-------------------------------------------

```r
for (i in 1:nrow(new_items)){
  if(new_items$`Primary ingredient`[i] == "SAM E" && 
     !is.na(new_items$`Primary ingredient`[i])){
    new_items$Category[i] <- "MISCELLANEOUS SUPPLEMENTS"
    new_items$Subcategory[i] <- "MISCELLANEOUS SUPPLEMENTS"
  }
}
```

Why: SAM-E is a special supplement that doesn't fit standard categories


4.3 RULE 3: ALGAE GROUP OVERRIDE (Lines 182-192)
-------------------------------------------------

```r
algae_group = c("SPIRULINA BLUE GREEN ALGAE",
                "ALGAE - OTHER",
                "SEA MOSS",
                "CHLOROPHYLL / CHLORELLA")

for (i in 1:nrow(new_items)){
  if(!is.na(new_items$`Primary ingredient`[i])){
    if(new_items$`Primary ingredient`[i] %in% algae_group){
      new_items$Category[i] = "HERBAL REMEDIES"
      new_items$Subcategory[i] = "FOOD SUPPLEMENTS"
    }
  }
}
```

Why: All algae products should be categorized as herbal food supplements


4.4 RULE 4: ECHINACEA GOLDENSEAL COMBO (Lines 193-196)
-------------------------------------------------------

```r
for (i in 1:nrow(new_items)){
  if(!is.na(new_items$`Primary ingredient`[i])){
    if(new_items$`Primary ingredient`[i] == "ECHINACEA GOLDENSEAL COMBO"){
      new_items$Category[i] <- "HERBAL/HOMEOPATHIC COLD & FLU"
      new_items$Subcategory[i] <- "HERBAL FORMULAS COLD & FLU"
    }
  }
}
```

Why: This specific combination is for cold & flu, not general herbal remedies


4.5 RULE 5: CHOLINE INOSITOL COMBO (Lines 197-200)
---------------------------------------------------

```r
for (i in 1:nrow(new_items)){
  if(!is.na(new_items$`Primary ingredient`[i])){
    if(new_items$`Primary ingredient`[i] == "CHOLINE AND INOSITOL (COMBO)"){
      new_items$Category[i] <- "MISCELLANEOUS SUPPLEMENTS"
      new_items$Subcategory[i] <- "MISCELLANEOUS SUPPLEMENTS"
    }
  }
}
```


4.6 RULE 6: COQ10 UBIQUINOL (Lines 201-204)
--------------------------------------------

```r
for (i in 1:nrow(new_items)){
  if(!is.na(new_items$`Primary ingredient`[i])){
    if(new_items$`Primary ingredient`[i] == "CO-ENZYME Q 10 - UBIQUINOL"){
      new_items$Category[i] <- "COENZYME Q10"
      new_items$Subcategory[i] <- "COENZYME Q10"
    }
  }
}
```

Why: CoQ10 Ubiquinol gets its own category (not in basic vitamins & minerals)


4.7 RULE 7: GLANDULAR OVERRIDE (Lines 205-208)
-----------------------------------------------

```r
for (i in 1:nrow(new_items)){
  if(!is.na(new_items$`Primary ingredient`[i])){
    if(new_items$`Primary ingredient`[i] == "GLANDULAR"){
      new_items$Category[i] <- "MISCELLANEOUS SUPPLEMENTS"
      new_items$Subcategory[i] <- "MISCELLANEOUS SUPPLEMENTS"
    }
  }
}
```


4.8 RULE 8: PROTEIN POWDER TITLE CHECK (Lines 209-213)
-------------------------------------------------------

```r
for (i in 1:nrow(new_items)){
  if(!is.na(new_items$`Primary ingredient`[i])){
    if(grepl('PROTEIN POWDER', new_items$Title[i])){
      new_items$Category[i] <- "ACTIVE NUTRITION"
      new_items$Subcategory[i] <- "PROTEIN & MEAL REPLACEMENTS"
    }
  }
}
```

Why: Catch protein products where ingredient detection failed but title is clear


4.9 RULE 9: WEIGHT LOSS KEYWORDS (Lines 217-227)
-------------------------------------------------

```r
for (i in 1:nrow(new_items)){
  if(grepl("WEIGHT LOSS", new_items$Title[i]) || 
     grepl("FAT BURN", new_items$Title[i]) || 
     grepl("APPETITE SUPPRESSANT", new_items$Title[i]) || 
     grepl("DIET PILL", new_items$Title[i])){
    
    if((new_items$`Primary ingredient`[i] == "CONJ LINOLEIC ACID" || 
        new_items$`Primary ingredient`[i] == "AFRICAN MANGO") && 
       !is.na(new_items$`Primary ingredient`[i])){
      new_items$Category[i] <- "WEIGHT MANAGEMENT FORMULAS"
      new_items$Subcategory[i] <- "MISCELLANEOUS SUPPLEMENTS"
    } else {
      new_items$Category[i] <- "WEIGHT MANAGEMENT FORMULAS"
      new_items$Subcategory[i] <- "WEIGHT MANAGEMENT FORMULAS"
    }
  }
}
```

Why: 
- Weight loss products get special category regardless of ingredient
- CLA and African Mango are special cases within weight management


4.10 SUMMARY OF BUSINESS RULES AFTER SCRIPT 1
----------------------------------------------

Total Rules: 9

Rule Priority (highest to lowest):
1. All protein types → ACTIVE NUTRITION
2. Weight loss keywords → WEIGHT MANAGEMENT FORMULAS
3. Specific ingredient overrides:
   - SAM-E → MISCELLANEOUS SUPPLEMENTS
   - Algae group → HERBAL REMEDIES / FOOD SUPPLEMENTS
   - Echinacea Goldenseal → HERBAL/HOMEOPATHIC COLD & FLU
   - Choline Inositol → MISCELLANEOUS SUPPLEMENTS
   - CoQ10 Ubiquinol → COENZYME Q10
   - Glandular → MISCELLANEOUS SUPPLEMENTS
4. Protein powder in title → ACTIVE NUTRITION (catch-all)

These rules OVERRIDE whatever Script 1 assigned!


================================================================================
SECTION 5: STATE AFTER SCRIPT 1 + BUSINESS RULES
================================================================================

At this point, each product has:
- RetailerSku (ASIN)
- Title (original, lowercase)
- Brand (original, lowercase)
- Primary ingredient (or NA if not found)
- other ing. 2, 3, 4... (if multiple ingredients)
- Category (from ingredient lookup OR business rule override)
- Subcategory (from ingredient lookup OR herb logic OR business rule override)

Still Missing (will be added by other scripts):
- Form
- Age
- Gender
- Count
- Unit Of Measurement
- Size
- Health Focus
- Organic
- High Level Category

Next Steps:
- Script 2 (Form Coding) will run
- Script 3 (Age Coding) will run
- Script 4 (Gender Coding) will run
- Script 5 (Count Size Coding) will run
- Script 6 (Pack Size Coding) will run
- Script 7 (Health Focus) will run
- All outputs merged
- More business rules applied
- Final cleanup and export


================================================================================
SECTION 6: SCRIPT 2 - FORM CODING FINAL.R
================================================================================

Purpose: Predict product form (Capsule, Tablet, Softgel, Powder, Gummy, etc.)
Method: Random Forest ML Model + Text Processing + Post-Processing Rules
Input: df_test (RetailerSku, Title, Brand)
Output: Form

Note: This script works INDEPENDENTLY - does not need ingredient/category data!


6.1 STEP 1: LOAD LOOKUP FILES (Lines 26-31)
--------------------------------------------

```r
# Token list used by ML model (42 form-related words)
FinalTokens <- read.delim('./TokenLists/FormTokenList.txt', header=FALSE)
# Examples: "capsul", "tablet", "softgel", "powder", "gummi", "liquid", etc.

# Text replacements to standardize form terms
TextReplacement <- read.csv('./TextTransforms/TextReplacementsForm.csv', header=TRUE)
# Examples: "soft gel" → "softgel", "veg cap" → "vegetable capsule"

# Load trained Random Forest model
FormModel <- readRDS("./FinalModels/FormModel_Final2.rda")
```

Model Tokens (42 total):
1. capsul
2. tablet
3. softgel
4. vegetablecapsul
5. powder
6. gummi
7. liquid
8. chewabletablet
9. caplet
10. drop
11. cap
12. lozeng
13. cream
14. gel
15. drink
16. softchew
17. bar
18. energychew
19. kit
20. pellet
21. suppositori
22. energygel
23. energygum
24. tinctur
25. bulk
26. shake
27. mist
28. vegetarian
29. chew
30. moistur
31. vegan
32. gum
33. lotion
34. skin
35. packet
36. fl (fluid)
37. loos (loose)
38. topic (topical)
39. facial
40. drugtest
41. sprai (spray)
42. (plus variations)


6.2 STEP 2: TEXT PREPROCESSING (Lines 33-46)
---------------------------------------------

Purpose: Standardize title text for better matching

6.2A Fix Text Encoding:
```r
TextReplacement$Text <- iconv(TextReplacement$Text, from="", to="UTF-8", sub="")
```

6.2B Add Spaces Around Search Terms (for exact matching):
```r
# Add spaces to prevent partial matches
TextReplacement$Text <- str_pad(TextReplacement$Text, 
                                width=nchar(TextReplacement$Text)+2, 
                                side="both")
# "softgel" → " softgel " (won't match "softgels" in middle of word)

TextReplacement$Replacement <- str_pad(TextReplacement$Replacement, 
                                       width=nchar(Replacement)+2, 
                                       side="both")
```

6.2C Pad Title and Remove Punctuation:
```r
df_test_form_form$Title <- str_pad(df_test_form_form$Title, 
                                   width=nchar(Title)+2, 
                                   side="both")
# "vitamin d 60 capsules" → " vitamin d 60 capsules "

df_test_form_form$Title <- str_replace_all(df_test_form_form$Title, "[[:punct:]]", " ")
# Remove commas, periods, hyphens → replace with spaces
```

6.2D Apply Text Replacements:
```r
df_test_form_form <- FindReplace(data=df_test_form_form, 
                                  Var='Title', 
                                  replaceData=TextReplacement, 
                                  from="Text", 
                                  to="Replacement", 
                                  exact=FALSE)
```

Common Replacements:
- "soft gel" → "softgel"
- "soft-gel" → "softgel"
- "veg cap" → "vegetable capsule"
- "veggie caps" → "vegetable capsules"
- "veg capsules" → "vegetable capsules"
- "liquid caps" → "softgel"
- "liquid capsule" → "softgel"
- "gel cap" → "softgel"

Why?
- Standardize variations
- ML model trained on specific terms
- Improve matching accuracy

Example:
Before: "nature's way turmeric 500mg 60 veg caps"
After:  "nature's way turmeric 500mg 60 vegetable capsules"


6.3 STEP 3: CREATE DOCUMENT-TERM MATRIX (Lines 48-72)
------------------------------------------------------

Purpose: Convert text to numerical features for ML model

6.3A Tokenization (Split into Words):
```r
ItemsTibble <- tibble(RetailerSku=df_test_form$RetailerSku, 
                      Title=df_test_form$Title)

ItemsTokenized <- ItemsTibble %>% unnest_tokens(word, Title)
```

Example:
Input:  "vitamin d 60 capsules"
Output: 
```
RetailerSku | word
B0001       | vitamin
B0001       | d
B0001       | 60
B0001       | capsules
```

6.3B Remove Stop Words:
```r
ItemsTokenNoStop <- ItemsTokenized %>% anti_join(stop_words)
```

Stop words removed: "the", "and", "with", "for", "a", "an", etc.

Example:
Before: ["vitamin", "d", "with", "60", "capsules"]
After:  ["vitamin", "d", "60", "capsules"]

6.3C Stem Words (Reduce to Base Form):
```r
ItemsTokenNoStopStemmed <- ItemsTokenNoStop %>% 
                           mutate(word=SnowballC::wordStem(word))
```

Stemming Examples:
- "capsules" → "capsul"
- "tablets" → "tablet"
- "gummies" → "gummi"
- "softgels" → "softgel"
- "powders" → "powder"

Why Stem?
- "capsule", "capsules", "caps" all become "capsul"
- Reduces vocabulary size
- Improves matching

6.3D Create Document-Term Matrix (DTM):
```r
ItemsDTM <- ItemsTokenNoStopStemmed %>% 
            dplyr::count(RetailerSku, word) %>%
            cast_dtm(document=RetailerSku, term=word, value=n)
```

Result: Sparse matrix where each row is a product, each column is a word, values are word counts

Example Matrix:
```
         capsul  tablet  softgel  powder  gummi  vitamin  d  500  mg
B0001       2       0       0        0       0      1      1   1    1
B0002       0       3       0        0       0      1      0   0    0
B0003       0       0       1        0       0      0      1   1    0
B0004       0       0       0        2       0      1      0   0    0
```

6.3E Inspect DTM:
```r
inspect(ItemsDTM)
```

Shows dimensions and sample of matrix.

6.3F Limit to Model Tokens ONLY:
```r
ItemsDTM <- ItemsDTM[, colnames(ItemsDTM) %in% as.character(FinalTokens$V1)]
```

Keep ONLY the 42 tokens the model was trained on.

Remove: "vitamin", "d", "500", "mg" (not form-related)
Keep: "capsul", "tablet", "softgel", "powder", "gummi"

Final Matrix:
```
         capsul  tablet  softgel  powder  gummi  liquid  chewabletablet  ...
B0001       2       0       0        0       0      0          0
B0002       0       3       0        0       0      0          0
B0003       0       0       1        0       0      0          0
B0004       0       0       0        2       0      0          0
```

6.3G Find Missing Tokens:
```r
TokenCheck <- FinalTokens[!(as.character(FinalTokens$V1) %in% colnames(ItemsDTM)),]
```

If some of the 42 model tokens aren't in new data, need to add them as zero columns.


6.4 STEP 4: HANDLE MISSING SKUS AND TOKENS (Lines 74-132)
----------------------------------------------------------

Purpose: Ensure all products and all model tokens are represented

6.4A Save DTM to CSV:
```r
write.csv(as.matrix(ItemsDTM), file="Data/df_test_form_formDTMOutputForm.csv")
df_test_form_formData2 <- read.csv('Data/df_test_form_formDTMOutputForm.csv')
```

6.4B Add Missing Tokens (As Zeros):
```r
df_test_form_formData2[, as.character(TokenCheck)] <- 0
```

If model expects "lozeng" token but none found in data → add column "lozeng" = 0

6.4C Handle Missing SKUs:
```r
missing_skus <- as.data.frame(df_test_form$RetailerSku[!(df_test_form$RetailerSku %in% df_test_form_formData2$X)])
```

Problem: Some products might have NO form-related words at all!
Example: "Nature's Way Super Formula" (no capsule, tablet, powder, etc. mentioned)

Solution: Add these products with all zeros

6.4D Create Missing SKU Rows with All Zeros:
```r
missing_skus <- missing_skus %>% add_column(
  a=0, b=0, c=0, d=0, e=0, f=0, g=0, h=0, i=0, j=0, k=0, l=0, m=0, n=0, o=0, 
  p=0, q=0, r=0, s=0, t=0, u=0, v=0, w=0, x=0, y=0, z=0, aa=0, bb=0, cc=0, 
  dd=0, ee=0, ff=0, gg=0, hh=0, ii=0, jj=0, kk=0, ll=0, mm=0, nn=0, oo=0
)
```

6.4E Name All 42 Columns:
```r
names(missing_skus)[1]  <- "X"
names(missing_skus)[2]  <- "capsul"
names(missing_skus)[3]  <- "tablet"
names(missing_skus)[4]  <- "softgel"
names(missing_skus)[5]  <- "vegetablecapsul"
names(missing_skus)[6]  <- "powder"
names(missing_skus)[7]  <- "gummi"
names(missing_skus)[8]  <- "liquid"
names(missing_skus)[9]  <- "chewabletablet"
names(missing_skus)[10] <- "caplet"
names(missing_skus)[11] <- "drop"
names(missing_skus)[12] <- "cap"
names(missing_skus)[13] <- "lozeng"
names(missing_skus)[14] <- "cream"
names(missing_skus)[15] <- "gel"
names(missing_skus)[16] <- "drink"
names(missing_skus)[17] <- "softchew"
names(missing_skus)[18] <- "bar"
names(missing_skus)[19] <- "energychew"
names(missing_skus)[20] <- "kit"
names(missing_skus)[21] <- "pellet"
names(missing_skus)[22] <- "suppositori"
names(missing_skus)[23] <- "energygel"
names(missing_skus)[24] <- "energygum"
names(missing_skus)[25] <- "tinctur"
names(missing_skus)[26] <- "bulk"
names(missing_skus)[27] <- "shake"
names(missing_skus)[28] <- "mist"
names(missing_skus)[29] <- "vegetarian"
names(missing_skus)[30] <- "chew"
names(missing_skus)[31] <- "moistur"
names(missing_skus)[32] <- "vegan"
names(missing_skus)[33] <- "gum"
names(missing_skus)[34] <- "lotion"
names(missing_skus)[35] <- "skin"
names(missing_skus)[36] <- "packet"
names(missing_skus)[37] <- "fl"
names(missing_skus)[38] <- "loos"
names(missing_skus)[39] <- "topic"
names(missing_skus)[40] <- "facial"
names(missing_skus)[41] <- "drugtest"
names(missing_skus)[42] <- "sprai"
```

6.4F Combine Back:
```r
df_test_form_formData2 <- rbind(missing_skus, df_test_form_formData2)
```

Now every product has exactly 42 token columns, even if all zeros.

6.4G Remove SKU Column for Model Input:
```r
df_test_form_formData3 <- df_test_form_formData2[,-1]
```

Model expects ONLY the 42 token counts, not the SKU.


6.5 STEP 5: RUN ML MODEL (Lines 136-146)
-----------------------------------------

```r
# Run Random Forest model to predict form
ItemsPredict <- predict(FormModel, df_test_form_formData2)

# Create output dataframe
ItemsPredictOutputForm <- data.frame(ItemsPredict)

# Add SKU column back
ItemsPredictOutputForm$RetailerSku <- df_test_form_formData2$X

# Rename prediction column
names(ItemsPredictOutputForm)[1] <- "Form"
ItemsPredictOutputForm$Form <- as.character(ItemsPredictOutputForm$Form)

# Reorder columns: SKU first, then Form
col_order <- c("RetailerSku", "Form")
ItemsPredictOutputForm <- ItemsPredictOutputForm[, col_order]
```

What Random Forest Does:
1. Looks at 42 token counts for each product
2. Compares to training data patterns
3. Predicts most likely form class
4. Returns: "Capsule", "Tablet", "Softgel", "Powder", "Gummy", etc.

Example Predictions:
```
Product A:
Tokens: capsul=2, vegetablecapsul=1, others=0
→ Prediction: "Vegetable Capsule"

Product B:
Tokens: tablet=3, chewabletablet=1, others=0
→ Prediction: "Chewable Tablet"

Product C:
Tokens: powder=2, others=0
→ Prediction: "Powder"

Product D:
Tokens: gummi=1, chew=1, others=0
→ Prediction: "Gummy"
```


6.6 STEP 6: POST-PROCESSING RULES (Lines 148-173)
--------------------------------------------------

Purpose: Override ML predictions with rule-based logic for known edge cases

6.6A Sort to Match Original Order:
```r
ItemsPredictOutputForm <- ItemsPredictOutputForm[order(ItemsPredictOutputForm$RetailerSku),]
df_test_form_form <- df_test_form_form[order(df_test_form_form$RetailerSku),]
```

6.6B Add Title Back (For Post-Processing):
```r
ItemsPredictOutputForm$Title <- df_test_form_form$Title
```

6.6C Apply 5 Post-Processing Rules:

RULE 1: Cough Drops / Throat Drops → Lozenge
```r
ItemsPredictOutputForm[grepl('cough drop', ItemsPredictOutputForm$Title) | 
                       grepl('throat drop', ItemsPredictOutputForm$Title), 'Form'] <- 'Lozenge'
```

Why: These specific terms always mean lozenge form
Example: "Ricola Cough Drops" → Form = "Lozenge" (even if model predicted otherwise)


RULE 2: "Powder" AND "Capsule" → Capsule
```r
ItemsPredictOutputForm[grepl('powder', ItemsPredictOutputForm$Title) & 
                       grepl('capsule', ItemsPredictOutputForm$Title), 'Form'] <- 'Capsule'
```

Why: "Powder in capsules" = capsule form, powder is ingredient state
Example: "Turmeric Powder in Capsules" → Form = "Capsule" (not "Powder")


RULE 3: "Vegetable Capsules" → Vegetable Capsule
```r
ItemsPredictOutputForm[grepl('vegetablecapsules', ItemsPredictOutputForm$Title) & 
                       ItemsPredictOutputForm$Form=='Capsule', 'Form'] <- 'Vegetable Capsule'
```

Why: If model predicted generic "Capsule" but title says "vegetable capsules", be specific
Example: Model says "Capsule", title has "vegetable capsules" → "Vegetable Capsule"


RULE 4: "Gel Capsule" or "Liquid Capsule" → Softgel
```r
ItemsPredictOutputForm[grepl('gel capsule', ItemsPredictOutputForm$Title) | 
                       grepl('liquid capsule', ItemsPredictOutputForm$Title), 'Form'] <- 'Softgel'
```

Why: These terms specifically mean softgel, not hard capsule
Example: "Fish Oil Liquid Capsules" → Form = "Softgel" (not "Capsule")


RULE 5: "Chew Tablet" → Chewable Tablet
```r
ItemsPredictOutputForm[grepl('chew tablet', ItemsPredictOutputForm$Title), 'Form'] <- 'Chewable Tablet'
```

Why: Distinguish from regular tablets
Example: "Vitamin C Chew Tablets" → Form = "Chewable Tablet"


Post-Processing Summary:
- 5 rules override ML predictions
- Based on clear text patterns
- Fix known misclassifications
- Improve accuracy by ~5-10%

6.6D Remove Title Column:
```r
ItemsPredictOutputForm <- ItemsPredictOutputForm[,-3]
```

Title was only needed for post-processing rules.


6.7 STEP 7: OUTPUT (Lines 172-178)
-----------------------------------

```r
# Write to CSV for inspection
write.csv(ItemsPredictOutputForm, './Outputs/ItemsCodedOutputForm.csv')
```

Final Output Structure:

ItemsPredictOutputForm
Columns:
- RetailerSku
- Form

Example Output:
```
RetailerSku | Form
B0001       | Vegetable Capsule
B0002       | Tablet
B0003       | Softgel
B0004       | Powder
B0005       | Gummy
B0006       | Liquid
B0007       | Chewable Tablet
B0008       | Lozenge
```

Possible Form Values:
- Capsule
- Vegetable Capsule
- Tablet
- Chewable Tablet
- Softgel
- Powder
- Gummy
- Liquid
- Drop
- Lozenge
- Caplet
- Cream
- Gel
- Drink
- Bar
- Softchew
- Kit
- Tincture
- Spray
- Lotion
- Packet
- Other (rare)


6.8 EDGE CASES & LIMITATIONS
-----------------------------

CASE 1: Title Has NO Form Words At All
---------------------------------------

Example: "Nature's Way Super Formula 100 count"

Flow:
1. Tokenization → ["natur", "way", "super", "formula", "count"]
2. Match against 42 model tokens → None match!
3. Product added to missing_skus with all zeros
4. ML Model Input: All 42 tokens = 0

What Model Does:
- Random Forest must make a prediction (can't return "Unknown")
- Predicts most common class in training data
- Usually: "Capsule" or "Tablet" (most common forms)

Result: Form = "Capsule" (GUESS - may be wrong!)

Problem: Silent failure - model assigns a form with low confidence

Manual Review Needed:
- Analysts filter for products where model might have guessed
- Check if assigned form makes sense
- Correct manually if wrong


CASE 2: Title Has NEW/Unknown Form Word
----------------------------------------

Example: "Vitamin D Sublingual Strips" (if "strip" wasn't in training data)

Flow:
1. Tokenization → ["vitamin", "d", "sublingu", "strip"]
2. Match against 42 model tokens → "strip" not in vocabulary!
3. All form tokens = 0

Result: Same as Case 1 - defaults to most common form (incorrect!)

Problem: Model can't handle new product forms not in training data


CASE 3: Title Has Conflicting Form Words
-----------------------------------------

Example: "Turmeric Powder in Vegetable Capsules"

Flow:
1. Tokenization → ["turmeric", "powder", "vegetabl", "capsul"]
2. Match → powder=1, capsul=1, vegetablecapsul=0
3. Model sees both "powder" and "capsul" tokens

Model Decision:
- Trained on products with both tokens
- Learned pattern: when both present, actual form is usually capsule
- Prediction: "Capsule"

Post-Processing:
- Rule 2 confirms: powder + capsule in title → "Capsule"

Result: Form = "Capsule" ✅ (CORRECT!)


CASE 4: Ambiguous/Unclear Form
-------------------------------

Example: "Liquid Vitamin D for Immunity"

Flow:
1. Tokenization → ["liquid", "vitamin", "d", "immun"]
2. Match → liquid=1

Problem: "Liquid" could mean:
- Liquid form (drops in bottle)
- Liquid capsule (softgel)
- Liquid softgel
- Liquid suspension

Model Prediction:
- Based on training data patterns
- Most products with "liquid" token are probably "Liquid" or "Drop"

Result: Form = "Liquid" or "Drop" (depends on training data)

Accuracy: ~70-80% on ambiguous cases


ABSENCE OF "UNKNOWN" OR CONFIDENCE SCORES
------------------------------------------

Limitation: The R code does NOT:
- Return "Unknown" for uncertain predictions
- Provide confidence scores
- Flag low-confidence predictions for review

The model must always predict one of the trained form classes.

Real-World Outcome:
- Products with unclear forms get assigned most common form
- Usually "Capsule" or "Tablet" (may be incorrect)
- Requires manual review to catch errors

Manual Review Process:
1. Export results
2. Filter for suspicious predictions:
   - Form = "Capsule" AND title has NO form words
   - Form = "Tablet" AND title contains "liquid"
   - Products with unusual titles
3. Manually verify/correct

This manual review was a standard part of the workflow.


================================================================================
SECTION 7: BUSINESS RULES AFTER SCRIPT 2 (FinalMerge.R Lines 383-393)
================================================================================

Purpose: Use Form to refine Subcategory for protein products

This rule runs AFTER all scripts merge (Form + Ingredient both available)


7.1 PROTEIN FORM-BASED SUBCATEGORY SPLIT
-----------------------------------------

```r
for (i in 1:nrow(new_items)){
  if(new_items$Subcategory[i] == "PROTEIN & MEAL REPLACEMENTS" && 
     !is.na(new_items$Subcategory[i])){
    
    new_items$Category[i] <- "ACTIVE NUTRITION"
    
    if(new_items$Form[i] == "POWDER" && !is.na(new_items$Form[i])){
      new_items$Subcategory[i] <- "DAILY NUTRITION"
    } else if(!is.na(new_items$Form[i])){
      new_items$Subcategory[i] <- "MEAL REPLACEMENTS"
    }
  }
}
```

Logic:
IF Product is protein (from Script 1):
  - Primary ingredient = any protein type
  - Subcategory = "PROTEIN & MEAL REPLACEMENTS" (assigned in business rules after Script 1)

THEN:
  IF Form = "POWDER":
    → Subcategory = "DAILY NUTRITION"
  ELSE (Form = anything else):
    → Subcategory = "MEAL REPLACEMENTS"

Why This Rule Exists:
- Protein products serve different purposes based on form
- Protein Powder = Mix into drinks, daily supplementation
- Protein Bar/Shake = Ready-to-consume meal replacement
- Same ingredient, different use case!

Example 1 - Protein Powder:
```
Primary ingredient: "PROTEIN - ANIMAL - WHEY"
Category: "ACTIVE NUTRITION" (from Script 1 business rule)
Subcategory: "PROTEIN & MEAL REPLACEMENTS" (from Script 1 business rule)
Form: "POWDER" (from Script 2)

→ AFTER THIS RULE:
Subcategory: "DAILY NUTRITION" (changed!)
```

Example 2 - Protein Bar:
```
Primary ingredient: "PROTEIN - PLANT - PEA"
Category: "ACTIVE NUTRITION"
Subcategory: "PROTEIN & MEAL REPLACEMENTS"
Form: "BAR" (from Script 2)

→ AFTER THIS RULE:
Subcategory: "MEAL REPLACEMENTS" (changed!)
```

Example 3 - Protein Shake (Liquid):
```
Primary ingredient: "PROTEIN - ANIMAL - WHEY"
Category: "ACTIVE NUTRITION"
Subcategory: "PROTEIN & MEAL REPLACEMENTS"
Form: "DRINK" (from Script 2)

→ AFTER THIS RULE:
Subcategory: "MEAL REPLACEMENTS"
```

Dependencies:
- Requires Script 1 (Functional Ingredient + Category/Subcategory)
- Requires Script 2 (Form)
- Must run AFTER both are merged


7.2 HYDRATION/ELECTROLYTE DETECTION (Lines 396-409)
----------------------------------------------------

```r
for (i in 1:nrow(new_items)){
  if(grepl("HYDRAT", new_items$Title[i]) && !(is.na(new_items$Title[i]))){
    if(!grepl("DEHYDRAT", new_items$Title[i])){
      new_items$Category[i] <- "ACTIVE NUTRITION"
      new_items$Subcategory[i] <- "HYDRATION"
    }
  }
  
  if(grepl("ELECTROLYTE", new_items$Title[i]) && !(is.na(new_items$Title[i]))){
    if(!grepl("CREATINE", new_items$Title[i])){
      new_items$Category[i] <- "ACTIVE NUTRITION"
      new_items$Subcategory[i] <- "HYDRATION"
    }
  }
}
```

Logic:
- IF title contains "HYDRAT" (but NOT "DEHYDRAT") → Category = "ACTIVE NUTRITION", Subcategory = "HYDRATION"
- IF title contains "ELECTROLYTE" (but NOT with "CREATINE") → Category = "ACTIVE NUTRITION", Subcategory = "HYDRATION"

Why:
- Hydration products are active nutrition, not standard supplements
- "Dehydrated" products (like dehydrated greens) are NOT hydration
- Creatine electrolyte is NOT primarily for hydration

Example:
```
Title: "GNC AMP Hydration Powder with Electrolytes"
→ Contains "HYDRATION" and "ELECTROLYTE"
→ Category: "ACTIVE NUTRITION"
→ Subcategory: "HYDRATION"
```


================================================================================
SECTION 8: STATE AFTER SCRIPT 2
================================================================================

At this point, each product has:
✅ RetailerSku
✅ Title
✅ Brand
✅ Primary ingredient (Script 1)
✅ other ing. 2, 3, 4... (Script 1)
✅ Category (Script 1 + business rules)
✅ Subcategory (Script 1 + herb logic + protein form split + hydration)
✅ Form (Script 2)

Still Missing (will be added by remaining scripts):
❌ Age
❌ Gender
❌ Count
❌ Unit Of Measurement
❌ Size
❌ Health Focus
❌ Organic
❌ High Level Category

Next Steps:
- Script 3 (Age Coding) will run
- Script 4 (Gender Coding) will run
- Script 5 (Count Size Coding) will run
- Script 6 (Pack Size Coding) will run
- Script 7 (Health Focus) will run
- All outputs merged
- More business rules applied (multivitamin subcategory refinement uses Age + Gender)
- Final cleanup and export


================================================================================
SCRIPT 2 SUMMARY
================================================================================

What Script 2 Does:
1. ✅ Loads 42 form-related tokens and text replacements
2. ✅ Standardizes form terms ("soft gel" → "softgel")
3. ✅ Tokenizes title (split into words)
4. ✅ Removes stop words
5. ✅ Stems words ("capsules" → "capsul")
6. ✅ Creates document-term matrix (42 columns of token counts)
7. ✅ Handles missing SKUs (products with no form words → all zeros)
8. ✅ Runs Random Forest ML model
9. ✅ Applies 5 post-processing rules for edge cases

Outputs:
- Form (e.g., "Capsule", "Tablet", "Softgel", "Powder", "Gummy")

Business Rules Using Form:
1. Protein form split: Powder → DAILY NUTRITION, Other → MEAL REPLACEMENTS
2. Hydration/Electrolyte detection (uses Title + assigns Category/Subcategory)

Accuracy:
- ~90% accurate on known forms
- Drops to ~70-80% on ambiguous cases
- Silent failures on products with no form words (guesses most common)

Limitations:
- Can't return "Unknown"
- Can't handle new form types not in training
- No confidence scores
- Requires manual review for edge cases

Method:
- Random Forest ML model (trained on historical data)
- 42 form-related tokens
- Text preprocessing + stemming
- Post-processing rules for known issues

Comparison to Ingredient Detection (Script 1):
- Much simpler (178 lines vs 960 lines)
- ML-based vs rule-based
- Independent processing (doesn't need other data)
- Fewer edge cases
- Higher base accuracy


================================================================================
END OF SCRIPT 2 DOCUMENTATION
================================================================================


================================================================================
SECTION 9: SCRIPT 3 - AGE CODING FINAL.R
================================================================================

Purpose: Predict target age group (Adult, Child, Teen, Mature Adult, Non-Specific)
Method: Random Forest ML Model + Text Processing
Input: df_test (RetailerSku, Title, Brand)
Output: Age

Note: This script works INDEPENDENTLY - does not need ingredient/category/form data!


9.1 STEP 1: LOAD LOOKUP FILES (Lines 22-26)
--------------------------------------------

```r
# Token list for ML model (22 age-related words)
FinalTokens <- read.delim('./TokenLists/AgeTokenList.txt', header=FALSE)

# Text replacements for age terms
TextReplacement <- read.csv('./TextTransforms/TextReplacementsAge.csv', header=TRUE)
```

Age Token List (22 tokens):
1. adult
2. child
3. teen
4. matur (mature)
5. teenag (teenager)
6. femal (female - used in age context)
7. children
8. prenat (prenatal)
9. infant
10. male (used in age context)
11. babi (baby)
12. kid
13. toddler
14. fertil (fertility)
15. boi (boy)
16. pregnanc (pregnancy)
17. girl
18. jr (junior)
19. newborn
20. X40 (40+ age indicator)
21. X50 (50+ age indicator)
22. (variations)

Common Text Replacements:
- "children's" → "child"
- "kids" → "child"
- "senior" → "mature adult"
- "50+" → "mature adult"
- "men's" → "adult male"
- "women's" → "adult female"
- "baby" → "infant"


9.2 STEP 2: TEXT PREPROCESSING (Lines 28-48)
---------------------------------------------

9.2A Add Spaces and Lowercase:
```r
TextReplacement$Text <- str_pad(TextReplacement$Text, 
                                width=nchar(TextReplacement$Text)+2, 
                                side="both")
TextReplacement$Text <- tolower(TextReplacement$Text)

TextReplacement$Replacement <- str_pad(TextReplacement$Replacement, 
                                       width=nchar(Replacement)+2, 
                                       side="both")
TextReplacement$Replacement <- tolower(TextReplacement$Replacement)
```

9.2B Pad Title and Remove Punctuation:
```r
df_test_age$Title <- str_pad(df_test_age$Title, 
                             width=nchar(Title)+2, 
                             side="both")

df_test_age$Title <- str_replace_all(df_test_age$Title, "[[:punct:]]", "")
```

9.2C Handle Empty Titles:
```r
for(i in 1:nrow(df_test_age)){
  if(df_test_age$Title[i] == ""){
    df_test_age$Title[i] <- "age non specific"
  }
}
```

Why: If title is completely empty, model needs some text to process.
Result: Empty titles default to "age non specific"

9.2D Apply Text Replacements:
```r
df_test_ageCD <- FindReplace(data=df_test_age, 
                              Var='Title', 
                              replaceData=TextReplacement, 
                              from="Text", 
                              to="Replacement", 
                              exact=FALSE)
```

Example:
Before: "children's multivitamin gummies"
After:  "child multivitamin gummies"


9.3 STEP 3: CREATE DOCUMENT-TERM MATRIX (Lines 50-92)
------------------------------------------------------

9.3A Load Model:
```r
AgeModel <- readRDS("./FinalModels/AgeModel_Final.rda")
```

9.3B Tokenization:
```r
ItemsTibble <- tibble(RetailerSku=df_test_ageCD$RetailerSku, 
                      Title=as.character(df_test_ageCD$Title))

ItemsTokenized <- ItemsTibble %>% unnest_tokens(word, Title)
```

Example:
Input:  "child vitamin gummies"
Output: 
```
RetailerSku | word
B0001       | child
B0001       | vitamin
B0001       | gummies
```

9.3C Remove Stop Words:
```r
ItemsTokenNoStop <- ItemsTokenized %>% anti_join(stop_words)
```

9.3D Stem Words:
```r
ItemsTokenNoStopStemmed <- ItemsTokenNoStop %>% 
                           mutate(word=SnowballC::wordStem(word))
```

Stemming Examples:
- "children" → "children" (already base)
- "adults" → "adult"
- "prenatal" → "prenat"
- "teenagers" → "teenag"

9.3E Create Document-Term Matrix:
```r
ItemsDTM <- ItemsTokenNoStopStemmed %>% 
            dplyr::count(RetailerSku, word) %>%
            cast_dtm(document=RetailerSku, term=word, value=n)
```

Result: Matrix with products as rows, words as columns, word counts as values

9.3F Limit to Model Tokens:
```r
ItemsDTM <- ItemsDTM[, colnames(ItemsDTM) %in% as.character(FinalTokens$V1)]
```

Keep only the 22 age-related tokens the model was trained on.

9.3G Find Missing Tokens:
```r
TokenCheck <- colnames(ItemsDTM)
TokenCheck2 <- FinalTokens[!(as.character(FinalTokens$V1) %in% TokenCheck),]
```


9.4 STEP 4: HANDLE MISSING SKUS AND TOKENS (Lines 89-124)
----------------------------------------------------------

9.4A Save and Reload DTM:
```r
write.csv(as.matrix(ItemsDTM), file="./Outputs/df_test_ageAgeDTMOutput.csv")
df_test_ageCDData2 <- read.csv('./Outputs/df_test_ageAgeDTMOutput.csv')
```

9.4B Add Missing Tokens:
```r
df_test_ageCDData2[, as.character(TokenCheck2)] <- 0
```

9.4C Handle Missing SKUs (products with no age-related words):
```r
missing_skus_age <- as.data.frame(df_test_age$RetailerSku[!(df_test_age$RetailerSku %in% df_test_ageCDData2$X)])

missing_skus_age <- missing_skus_age %>%
  add_column(a=0, b=0, c=0, d=0, e=0, f=0, g=0, h=0, i=0, j=0, k=0, l=0, 
             m=0, n=0, o=0, p=0, q=0, r=0, s=0, t=0, u=0)
```

9.4D Name All 22 Columns:
```r
names(missing_skus_age)[1]  <- "X"
names(missing_skus_age)[2]  <- "adult"
names(missing_skus_age)[3]  <- "child"
names(missing_skus_age)[4]  <- "teen"
names(missing_skus_age)[5]  <- "matur"
names(missing_skus_age)[6]  <- "teenag"
names(missing_skus_age)[7]  <- "femal"
names(missing_skus_age)[8]  <- "children"
names(missing_skus_age)[9]  <- "prenat"
names(missing_skus_age)[10] <- "infant"
names(missing_skus_age)[11] <- "male"
names(missing_skus_age)[12] <- "babi"
names(missing_skus_age)[13] <- "kid"
names(missing_skus_age)[14] <- "toddler"
names(missing_skus_age)[15] <- "fertil"
names(missing_skus_age)[16] <- "boi"
names(missing_skus_age)[17] <- "pregnanc"
names(missing_skus_age)[18] <- "girl"
names(missing_skus_age)[19] <- "jr"
names(missing_skus_age)[20] <- "newborn"
names(missing_skus_age)[21] <- "X40"
names(missing_skus_age)[22] <- "X50"
```

9.4E Combine and Remove SKU Column:
```r
df_test_ageCDData2 <- rbind(missing_skus_age, df_test_ageCDData2)
df_test_ageCDData3 <- df_test_ageCDData2[,-1]
```


9.5 STEP 5: RUN ML MODEL (Lines 126-145)
-----------------------------------------

```r
# Predict age group
ItemsPredict <- predict(AgeModel, df_test_ageCDData3)

# Create output dataframe
ItemsPredictOutputAge <- as.data.frame(ItemsPredict)

# Add SKU back
ItemsPredictOutputAge$RetailerSku <- df_test_ageCDData2$X

# Rename and reorder
colnames(ItemsPredictOutputAge)[1] <- "Age"
ItemsPredictOutputAge$Age <- as.character(ItemsPredictOutputAge$Age)
ItemsPredictOutputAge <- ItemsPredictOutputAge[c(2,1)]
```

Model Output Classes:
- AGE GROUP - ADULT
- AGE GROUP - CHILD
- AGE GROUP - TEEN
- AGE GROUP - MATURE ADULT
- AGE GROUP - NON SPECIFIC

Example Predictions:
```
Product A:
Tokens: child=1, kid=1, others=0
→ Prediction: "AGE GROUP - CHILD"

Product B:
Tokens: matur=1, X50=1, others=0
→ Prediction: "AGE GROUP - MATURE ADULT"

Product C:
Tokens: prenat=1, pregnanc=1, others=0
→ Prediction: "AGE GROUP - ADULT" (prenatal targets adult women)

Product D:
Tokens: all=0
→ Prediction: "AGE GROUP - NON SPECIFIC"
```


9.6 OUTPUT
----------

ItemsPredictOutputAge

Columns:
- RetailerSku
- Age

Example Output:
```
RetailerSku | Age
B0001       | AGE GROUP - ADULT
B0002       | AGE GROUP - CHILD
B0003       | AGE GROUP - MATURE ADULT
B0004       | AGE GROUP - NON SPECIFIC
B0005       | AGE GROUP - TEEN
```


9.7 EDGE CASES
--------------

CASE 1: No Age Indicators in Title
-----------------------------------

Example: "Daily Multivitamin Formula"

Flow:
1. Tokenization → ["daili", "multivitamin", "formula"]
2. Match against 22 age tokens → None found
3. All age token counts = 0
4. Model must predict → defaults to most common: "AGE GROUP - NON SPECIFIC"

Result: Age = "AGE GROUP - NON SPECIFIC"


CASE 2: Multiple Age Indicators
--------------------------------

Example: "Adult & Teen Vitamin Complex"

Flow:
1. Tokens: adult=1, teen=1
2. Model trained on such cases
3. Predicts based on which is more prominent in training data
4. Usually: "AGE GROUP - ADULT" (more common in training)

Result: May not capture both age groups (picks dominant one)


CASE 3: Ambiguous Age Terms
----------------------------

Example: "Family Multivitamin"

Flow:
1. "Family" → no specific age token
2. All counts = 0
3. Prediction: "AGE GROUP - NON SPECIFIC"

Result: Correct classification - it's for all ages


CASE 4: Prenatal Products
--------------------------

Example: "Prenatal DHA 200mg"

Flow:
1. Tokens: prenat=1
2. Model prediction: "AGE GROUP - ADULT" (prenatal targets adult women, not children)

Result: Age = "AGE GROUP - ADULT"

Note: Prenatal products get Age = ADULT, then multivitamin subcategory logic (if applicable) 
      changes Subcategory to "PRENATAL" based on title keyword.


================================================================================
SECTION 10: STATE AFTER SCRIPT 3
================================================================================

At this point, each product has:
✅ RetailerSku
✅ Title
✅ Brand
✅ Primary ingredient (Script 1)
✅ other ing. 2, 3, 4... (Script 1)
✅ Category (Script 1 + business rules)
✅ Subcategory (Script 1 + herb logic + protein form split + hydration)
✅ Form (Script 2)
✅ Age (Script 3)

Still Missing (will be added by remaining scripts):
❌ Gender (Script 4)
❌ Count (Script 5)
❌ Unit Of Measurement (Script 5)
❌ Size (Script 6)
❌ Health Focus (Script 7)
❌ Organic (post-processing)
❌ High Level Category (post-processing)

Note: Age will be used later in combination with Gender (Script 4) for multivitamin subcategory refinement.


================================================================================
SCRIPT 3 SUMMARY
================================================================================

What Script 3 Does:
1. ✅ Loads 22 age-related tokens and text replacements
2. ✅ Standardizes age terms ("children's" → "child")
3. ✅ Handles empty titles (defaults to "age non specific")
4. ✅ Tokenizes title
5. ✅ Removes stop words
6. ✅ Stems words
7. ✅ Creates document-term matrix (22 columns)
8. ✅ Handles missing SKUs (products with no age words → all zeros)
9. ✅ Runs Random Forest ML model

Outputs:
- Age (e.g., "AGE GROUP - ADULT", "AGE GROUP - CHILD", etc.)

Business Rules Using Age:
- Age will be used later with Gender (Script 4) for multivitamin subcategory refinement

Accuracy:
- ~85-90% on clear age indicators
- Defaults to "NON SPECIFIC" when no age terms present

Limitations:
- Can't handle multiple age groups in single product
- No confidence scores for uncertain predictions
- Ambiguous terms like "family" default to NON SPECIFIC

Method:
- Random Forest ML model (similar to Form coding)
- 22 age-related tokens
- Text preprocessing + stemming
- No post-processing rules (unlike Form coding)


================================================================================
END OF SCRIPT 3 DOCUMENTATION
================================================================================


================================================================================
SECTION 11: SCRIPT 4 - GENDER CODING FINAL.R
================================================================================

Purpose: Predict target gender (Male, Female, Non-Specific)
Method: Random Forest ML Model + Text Processing
Input: df_test (RetailerSku, Title, Brand)
Output: Gender

Note: Simplest ML script - only 6 tokens (vs 42 for Form, 22 for Age)


12.1 STEP 1: LOAD LOOKUP FILES (Lines 22-27)
---------------------------------------------

```r
# Text replacements for gender terms
TextReplacement <- read.csv('./TextTransforms/TextReplacementsGender.csv', header=TRUE)

# Token list for ML model (only 6 tokens)
FinalTokens <- read.delim('./TokenLists/GenderTokenList.txt', header=FALSE)

# Load trained model
GenderModel <- readRDS("./FinalModels/GenderModel_Final.rda")
```

Gender Token List (6 tokens - smallest of all models):
1. male
2. femal (female)
3. nail (beauty/women indicator)
4. pregnant
5. preggi (preggy/pregnancy)
6. (only 6 total)

Why so few?
- Gender is simpler to detect than age or form
- Key indicators: male, female, pregnancy-related, beauty-related
- Most products are gender non-specific

Common Text Replacements:
- "men's" → "male"
- "women's" → "female"
- "for men" → "male"
- "for women" → "female"
- "prenatal" → "pregnant female"


12.2 STEP 2: TEXT PREPROCESSING (Lines 29-48)
----------------------------------------------

Same pattern as Form and Age scripts:

12.2A Add Spaces and Lowercase:
```r
TextReplacement$Text <- str_pad(TextReplacement$Text, width=nchar(Text)+2, side="both")
TextReplacement$Text <- tolower(TextReplacement$Text)
TextReplacement$Replacement <- str_pad(TextReplacement$Replacement, width=nchar(Replacement)+2, side="both")
TextReplacement$Replacement <- tolower(TextReplacement$Replacement)
```

12.2B Pad Title and Remove Punctuation:
```r
df_test_gender$Title <- str_pad(df_test_gender$Title, width=nchar(Title)+2, side="both")
df_test_gender$Title <- str_replace_all(df_test_gender$Title, "[[:punct:]]", "")
```

12.2C Handle Empty Titles:
```r
for(i in 1:nrow(df_test_gender)){
  if(df_test_gender$Title[i] == ""){
    df_test_gender$Title[i] <- "gender non specific"
  }
}
```

12.2D Apply Text Replacements:
```r
df_test_genderCD <- FindReplace(data=df_test_gender, Var='Title', 
                                replaceData=TextReplacement, from="Text", to="Replacement")
```

Example:
Before: "men's multivitamin"
After:  "male multivitamin"


12.3 STEP 3: CREATE DOCUMENT-TERM MATRIX (Lines 50-83)
-------------------------------------------------------

Same NLP pipeline as Form and Age:

12.3A Tokenization:
```r
ItemsTibble <- tibble(RetailerSku=df_test_genderCD$RetailerSku, Title=as.character(df_test_genderCD$Title))
ItemsTokenized <- ItemsTibble %>% unnest_tokens(word, Title)
```

12.3B Remove Stop Words:
```r
ItemsTokenNoStop <- ItemsTokenized %>% anti_join(stop_words)
```

12.3C Stem Words:
```r
ItemsTokenNoStopStemmed <- ItemsTokenNoStop %>% mutate(word=SnowballC::wordStem(word))
```

Stemming:
- "female" → "femal"
- "males" → "male"
- "nails" → "nail"

12.3D Create DTM:
```r
ItemsDTM <- ItemsTokenNoStopStemmed %>% 
            dplyr::count(RetailerSku, word) %>%
            cast_dtm(document=RetailerSku, term=word, value=n)
```

12.3E Limit to Model Tokens:
```r
ItemsDTM <- ItemsDTM[, colnames(ItemsDTM) %in% as.character(FinalTokens$V1)]
```

12.3F Find Missing Tokens:
```r
TokenCheck <- FinalTokens[!(as.character(FinalTokens$V1) %in% colnames(ItemsDTM)),]
```


12.4 STEP 4: HANDLE MISSING SKUS AND TOKENS (Lines 85-101)
-----------------------------------------------------------

Same handling as Form and Age:

12.4A Save/Reload DTM:
```r
write.csv(as.matrix(ItemsDTM), file="./Outputs/df_test_genderGenderDTMOutput.csv")
df_test_genderCDData2 <- read.csv('./Outputs/df_test_genderGenderDTMOutput.csv')
```

12.4B Add Missing Tokens:
```r
df_test_genderCDData2[, as.character(TokenCheck)] <- 0
```

12.4C Handle Missing SKUs:
```r
missing_skus <- as.data.frame(df_test_gender$RetailerSku[!(df_test_gender$RetailerSku %in% df_test_genderCDData2$X)])
missing_skus <- missing_skus %>% add_column(a=0, b=0, c=0, d=0, e=0)
```

12.4D Name 6 Columns:
```r
names(missing_skus)[1] <- "X"
names(missing_skus)[2] <- "male"
names(missing_skus)[3] <- "femal"
names(missing_skus)[4] <- "nail"
names(missing_skus)[5] <- "pregnant"
names(missing_skus)[6] <- "preggi"
```

12.4E Combine:
```r
df_test_genderCDData2 <- rbind(missing_skus, df_test_genderCDData2)
df_test_genderCDData3 <- df_test_genderCDData2[,-1]
```


12.5 STEP 5: RUN ML MODEL (Lines 103-127)
------------------------------------------

```r
# Predict gender
ItemsPredict <- predict(GenderModel, df_test_genderCDData3)

# Create output
ItemsPredictOutputGender <- data.frame(ItemsPredict)
ItemsPredictOutputGender$RetailerSku <- df_test_genderCDData2$X
colnames(ItemsPredictOutputGender)[1] <- "Gender"
ItemsPredictOutputGender$Gender <- as.character(ItemsPredictOutputGender$Gender)
ItemsPredictOutputGender <- ItemsPredictOutputGender[c(2,1)]

# Write output
write.csv(ItemsPredictOutputGender, './Outputs/GenderCodedOutput.csv')
```

Model Output Classes:
- GENDER - MALE
- GENDER - FEMALE
- GENDER - NON SPECIFIC

Example Predictions:
```
Product A: male=1, others=0 → "GENDER - MALE"
Product B: femal=1, pregnant=1 → "GENDER - FEMALE"
Product C: nail=1, femal=1 → "GENDER - FEMALE" (beauty indicator)
Product D: all=0 → "GENDER - NON SPECIFIC"
```


12.6 OUTPUT
-----------

ItemsPredictOutputGender

Columns:
- RetailerSku
- Gender

Example:
```
RetailerSku | Gender
B0001       | GENDER - MALE
B0002       | GENDER - FEMALE
B0003       | GENDER - NON SPECIFIC
```


12.7 EDGE CASES
---------------

CASE 1: No Gender Indicators
Example: "Vitamin D 5000 IU"
Result: "GENDER - NON SPECIFIC" (correct - for anyone)

CASE 2: Beauty/Nail Products
Example: "Biotin for Hair Skin and Nails"
Tokens: nail=1
Result: "GENDER - FEMALE" (beauty products typically target women)

CASE 3: Pregnancy Products
Example: "Prenatal Vitamins with DHA"
Tokens: pregnant=1
Result: "GENDER - FEMALE" (correct)

CASE 4: Both Genders Mentioned
Example: "Hormone Support for Men and Women"
Tokens: male=1, femal=1
Result: Usually "GENDER - NON SPECIFIC" (reasonable)


================================================================================
SECTION 12: BUSINESS RULES USING AGE + GENDER (FinalMerge.R Lines 236-277, 633-640)
================================================================================

Now that BOTH Age (Script 3) AND Gender (Script 4) are available, two business rules execute:


12.1 MULTIVITAMIN SUBCATEGORY REFINEMENT (Lines 236-277)
---------------------------------------------------------

Purpose: Refine multivitamin subcategories using Age + Gender combination

This runs AFTER Scripts 1, 3, and 4 merge (Category + Age + Gender all available)

Important: This CHANGES the Subcategory column that was created in Script 1!

```r
for (i in 1:nrow(new_items)){
  if(new_items$Category[i] == "COMBINED MULTIVITAMINS" && !is.na(new_items$Category[i])){
    
    # AGE-BASED FIRST (Lines 238-242)
    if(new_items$Age[i] == "AGE GROUP - CHILD"){
      new_items$Subcategory[i] = "CHILD"
    } else if(new_items$Age[i] == "AGE GROUP - TEEN"){
      new_items$Subcategory[i] = "TEEN"
    }
    
    # THEN AGE + GENDER COMBINATION (Lines 243-271)
    if (!is.na(new_items$Gender[i])){
      
      # MALE (Lines 244-252)
      if(new_items$Gender[i] == "GENDER - MALE") { 
        if(new_items$Age[i] == "AGE GROUP - ADULT" || 
           new_items$Age[i] == "AGE GROUP - NON SPECIFIC"){
          new_items$Subcategory[i] <- "MEN"
        } else if(new_items$Age[i] == "AGE GROUP - MATURE ADULT"){
          new_items$Subcategory[i] <- "MEN MATURE"
        } else {
          new_items$Subcategory[i] <- "ADULT"
        }
      } 
      
      # FEMALE (Lines 253-261)
      else if(new_items$Gender[i] == "GENDER - FEMALE") { 
        if(new_items$Age[i] == "AGE GROUP - ADULT" || 
           new_items$Age[i] == "AGE GROUP - NON SPECIFIC"){
          new_items$Subcategory[i] <- "WOMEN"
        } else if(new_items$Age[i] == "AGE GROUP - MATURE ADULT"){
          new_items$Subcategory[i] <- "WOMEN MATURE"
        } else {
          new_items$Subcategory[i] <- "ADULT"
        }
      } 
      
      # NON SPECIFIC GENDER (Lines 262-270)
      else if(new_items$Gender[i] == "GENDER - NON SPECIFIC") { 
        if(new_items$Age[i] == "AGE GROUP - ADULT"){
          new_items$Subcategory[i] <- "ADULT"
        } else if(new_items$Age[i] == "AGE GROUP - NON SPECIFIC"){
          new_items$Subcategory[i] <- "NON-SPECIFIC"
        } else if(new_items$Age[i] == "AGE GROUP - MATURE ADULT"){
          new_items$Subcategory[i] <- "MATURE ADULT"
        }
      }
    }
    
    # TITLE OVERRIDE - HIGHEST PRIORITY (Lines 273-275)
    if(grepl('PRENATAL', new_items$Title[i]) || 
       grepl("POSTNATAL", new_items$Title[i])){
      new_items$Subcategory[i] <- "PRENATAL"
    }
  }
}
```

Logic Flow:
1. Check if Category = "COMBINED MULTIVITAMINS"
2. Apply Age-based rules (Child, Teen)
3. Apply Age + Gender combinations (Men, Women, Men Mature, Women Mature, etc.)
4. Override with title keywords if present (Prenatal, Postnatal)

Subcategory Decision Matrix:

IF Category = "COMBINED MULTIVITAMINS":

Age = CHILD → Subcategory = "CHILD"
Age = TEEN → Subcategory = "TEEN"

Age = ADULT + Gender = MALE → Subcategory = "MEN"
Age = ADULT + Gender = FEMALE → Subcategory = "WOMEN"
Age = ADULT + Gender = NON SPECIFIC → Subcategory = "ADULT"

Age = MATURE ADULT + Gender = MALE → Subcategory = "MEN MATURE"
Age = MATURE ADULT + Gender = FEMALE → Subcategory = "WOMEN MATURE"
Age = MATURE ADULT + Gender = NON SPECIFIC → Subcategory = "MATURE ADULT"

Age = NON SPECIFIC + Gender = MALE → Subcategory = "MEN"
Age = NON SPECIFIC + Gender = FEMALE → Subcategory = "WOMEN"
Age = NON SPECIFIC + Gender = NON SPECIFIC → Subcategory = "NON-SPECIFIC"

Title contains "PRENATAL" or "POSTNATAL" → Subcategory = "PRENATAL" (overrides all above)

Example Transformations:

Example 1 - Child Multivitamin:
Script 1: Category = "COMBINED MULTIVITAMINS", Subcategory = "COMBINED MULTIVITAMINS"
Script 3: Age = "AGE GROUP - CHILD"
Business Rule: Subcategory = "CHILD" (CHANGED)

Example 2 - Men's Multivitamin:
Script 1: Category = "COMBINED MULTIVITAMINS", Subcategory = "COMBINED MULTIVITAMINS"
Script 3: Age = "AGE GROUP - ADULT"
Script 4: Gender = "GENDER - MALE"
Business Rule: Subcategory = "MEN" (CHANGED)

Example 3 - Women 50+ Multivitamin:
Script 1: Category = "COMBINED MULTIVITAMINS", Subcategory = "COMBINED MULTIVITAMINS"
Script 3: Age = "AGE GROUP - MATURE ADULT"
Script 4: Gender = "GENDER - FEMALE"
Business Rule: Subcategory = "WOMEN MATURE" (CHANGED)

Example 4 - Prenatal Multivitamin:
Title: "Nature's Way Prenatal Multivitamin"
Script 1: Category = "COMBINED MULTIVITAMINS", Subcategory = "COMBINED MULTIVITAMINS"
Script 3: Age = "AGE GROUP - ADULT"
Script 4: Gender = "GENDER - FEMALE"
Business Rule: Subcategory = "PRENATAL" (Title override beats Age + Gender)

Key Understanding:
- Subcategory column is created in Script 1
- This SAME column is overridden by this business rule
- Progressive refinement: Script 1 → herb logic → protein form → multivitamin age/gender


12.2 GENDER-BASED HEALTH FOCUS CORRECTION (Lines 633-640)
----------------------------------------------------------

Purpose: Fix conflicting Health Focus and Gender assignments

```r
for (i in 1:nrow(new_items)){
  # If Health Focus says MEN'S but Gender says FEMALE
  if(new_items$`Health Focus`[i] == "MEN'S HEALTH" && 
     !is.na(new_items$`Health Focus`[i]) && 
     new_items$`Gender`[i] == "GENDER - FEMALE" && 
     !is.na(new_items$`Gender`[i])){
    new_items$`Health Focus`[i] <- "WOMEN'S HEALTH"
  } 
  
  # If Health Focus says WOMEN'S but Gender says MALE
  else if(new_items$`Health Focus`[i] == "WOMEN'S HEALTH" && 
          !is.na(new_items$`Health Focus`[i]) && 
          new_items$`Gender`[i] == "GENDER - MALE" && 
          !is.na(new_items$`Gender`[i])){
    new_items$`Health Focus`[i] <- "MEN'S HEALTH"
  }
}
```

Why This Rule Exists:
- Health Focus (Script 7) and Gender (Script 4) are predicted separately
- They may conflict
- Gender model is more reliable for gender determination
- If conflict: trust Gender, override Health Focus

Example:
Product: "Prostate Support with Saw Palmetto"
Gender (Script 4): "GENDER - MALE" (correct)
Health Focus (Script 7): "MEN'S HEALTH" (correct)
→ No change needed

But if somehow:
Gender (Script 4): "GENDER - FEMALE" (wrong)
Health Focus (Script 7): "MEN'S HEALTH" (correct - prostate)
→ Business Rule changes Health Focus to "WOMEN'S HEALTH" (trusts Gender model)


================================================================================
SECTION 13: STATE AFTER SCRIPTS 2, 3, 4 (FORM, AGE, GENDER)
================================================================================

At this point, each product has:
✅ RetailerSku
✅ Title
✅ Brand
✅ Primary ingredient (Script 1)
✅ other ing. 2, 3, 4... (Script 1)
✅ Category (Script 1 + business rules)
✅ Subcategory (Script 1 + herb logic + protein form split + multivitamin refinement)
   NOTE: Now multivitamin subcategories CAN be fully refined (Age + Gender available)
✅ Form (Script 2)
✅ Age (Script 3)
✅ Gender (Script 4)

Still Missing (will be added by remaining scripts):
❌ Count (Script 5)
❌ Unit Of Measurement (Script 5)
❌ Size (Script 6)
❌ Health Focus (Script 7)
❌ Organic (post-processing)
❌ High Level Category (post-processing)

Next Steps:
- Script 5 (Count Size Coding) will run - DIFFERENT METHOD (regex, not ML)
- Script 6 (Pack Size Coding) will run - DIFFERENT METHOD (regex, not ML)
- Script 7 (Health Focus) will run - DIFFERENT METHOD (XGBoost, not Random Forest)
- More business rules applied
- Final cleanup and export


================================================================================
SCRIPTS 2-4 SUMMARY (FORM, AGE, GENDER)
================================================================================

Common Pattern - All Three Use:
1. ✅ Random Forest ML models
2. ✅ Same NLP pipeline (tokenize, stem, DTM)
3. ✅ Same handling for missing tokens/SKUs
4. ✅ Work independently from same input (df_test)
5. ✅ Can run in parallel

Key Differences:
- Tokens: Form=42, Age=22, Gender=6
- Output classes: Form=15+, Age=5, Gender=3
- Post-processing: Form has 5 text rules, Age/Gender have none

Outputs:
- Script 2: Form (Capsule, Tablet, Softgel, Powder, Gummy, etc.)
- Script 3: Age (ADULT, CHILD, TEEN, MATURE ADULT, NON SPECIFIC)
- Script 4: Gender (MALE, FEMALE, NON SPECIFIC)

Business Rules Using These Outputs:
1. Protein form split (uses Form from Script 2)
2. Multivitamin subcategory (uses Age from Script 3 + Gender from Script 4)
3. Health focus gender correction (uses Gender from Script 4)

Typical Accuracy: ~85-90% for all three

Limitations (all three):
- Default to most common class when uncertain
- No confidence scores provided
- Require manual review for edge cases
- Can't return "Unknown"

Method Comparison:
- Script 1 (Ingredients): Rule-based lookup + conditional logic (960 lines, complex)
- Scripts 2-4 (Form/Age/Gender): ML-based (150-180 lines each, simpler)
- Scripts 5-6 (Count/Size): Regex-based (coming next)
- Script 7 (Health Focus): XGBoost ML (coming next)


================================================================================
END OF SCRIPTS 2-4 DOCUMENTATION
================================================================================


================================================================================
SECTION 14: SCRIPT 5 - COUNT SIZE CODING FINAL LB UPDATE.R
================================================================================

Purpose: Extract Count (numeric value) and Unit Of Measurement (COUNT or OZ)
Method: REGEX PATTERN MATCHING (NOT ML!)
Input: df_test (RetailerSku, Title, Brand)
Output: Count, Unit Of Measurement

Key Difference: This script uses regular expressions, NOT machine learning!


14.1 STEP 1: TEXT PREPROCESSING (Lines 15-39)
----------------------------------------------

14.1A Load Text Replacements:
```r
TextReplacement <- read.csv('./TextTransforms/countReplacements.csv', header=TRUE)
```

Purpose: Standardize problematic terms that confuse regex

Common Replacements:
- "CoQ10" → "COQTEN" (so "10" isn't extracted as count)
- "Omega-3" → "FishOil" (so "3" isn't extracted)
- "B1", "B9" → "VITAMINB" (vitamin numbers aren't counts)
- "IP-6" → "IPSIX" (ingredient number isn't count)

Why? Numbers in ingredient names would be incorrectly extracted as counts.

14.1B Apply Replacements:
```r
df_test_count$Title <- tolower(df_test_count$Title)
df_test_count <- FindReplace(data=df_test_count, Var='Title', replaceData=TextReplacement)
```

14.1C Replace Problem Strings:
```r
df_test_count$Title <- str_replace_all(df_test_count$Title, '1/2', ".5")     # "1/2" → "0.5"
df_test_count$Title <- str_replace_all(df_test_count$Title, '\\+', "plus")   # "+" → "plus"
df_test_count$Title <- str_replace_all(df_test_count$Title, '\\&', "and")    # "&" → "and"
df_test_count$Title <- str_replace_all(df_test_count$Title, '\\-', " ")      # "-" → space
df_test_count$Title <- str_replace_all(df_test_count$Title, '/', " ")        # "/" → space
df_test_count$Title <- str_replace_all(df_test_count$Title, '\\)', " ")      # Remove parentheses
df_test_count$Title <- str_replace_all(df_test_count$Title, '\\(', " ")
```

Example Transformation:
```
Before: "Nature's Way CoQ10 100mg 60+30 Softgels"
After:  "nature's way coqten 100mg 60plus30 softgels"
```


14.2 STEP 2: PRIMARY REGEX EXTRACTION (Lines 45-93)
----------------------------------------------------

14.2A Define Huge Regex Pattern:
```r
count_pattern <- "(((\\d{1,4}|(\\d{1,2}\\.\\d{1,2})|(\\.\\d{1,2}))\\s*(count|ct|ct.|caps|vcaps|
vegcaps|veggie caps|vegetable caps|veg capsules|caplet|caps|pcs|strips|cap|drcaps|veg drcaps|
veg caps|chewable|gummy|tabs|tab|gummies|sg|sgels|soft chews|liquid softgels|packet|packets|
box|bags|tea bags|capsules|veggie capsules|capsule|chew tabs|chewable tablets|tablets|tablet|
pill|piece|throat drops|cough drops|drops|veg. cap|fl ozs|fluid ozs|fluid oz|fluid ounce|
fl oz|fl. oz|fl.oz|oz|fl ounces|ounces|ounce|chwbls|chewable gummies|vegetarian capsules|
vegicaps|ea|each|lozenges|lozenge|sachets|sachet|serving|vtab|beadlet|vegan cap|vegetarian caps|
vegan tab|sprays|mini softgels|liquid soft gels|softgels|soft gels|soft gel|softgel|liquidgels|
pellets|pellet|vegan friendly capsules|wafers|rapid release softgel|gelatin capsule|
quick dissolve tablet|per pack))|\\d{1,3}(ct.|ct|oz\\s*|oz.|count|cap|ea|each))"
```

What It Finds:
- Pattern: [NUMBER] [UNIT]
- Numbers: 1-4 digits, decimals like "1.5", ".5"
- Units: 80+ variations (capsules, tablets, oz, fl oz, count, etc.)

14.2B Extract Matches:
```r
string_matches <- str_extract(df_test_count$Title, count_pattern)
```

Example Extractions:
```
"vitamin d 5000 iu 60 softgels" → "60 softgels"
"fish oil 1000mg 180 caps" → "180 caps"
"elderberry 8 fl oz" → "8 fl oz"
"protein powder 2 lbs" → NO MATCH (lbs not in primary pattern)
```

14.2C Split into Count and Unit:
```r
count_final$Count_numeric <- str_extract(count_final$Count, "((((\\d{1,2}\\.\\d{1,2})|(\\.\\d{1,2}|\\d{1,4}))))")
count_final$Count <- gsub("((((\\d{1,2}\\.\\d{1,2})|(\\.\\d{1,2}|\\d{1,4}|))))", "", count_final$Count)
```

Example:
```
"60 softgels" → Count_numeric="60", Count="softgels"
"8 fl oz" → Count_numeric="8", Count="fl oz"
```

14.2D Categorize Unit Type:
```r
for(i in 1:nrow(count_final)){
  if(grepl("ounces|ounce|oz", count_final$Count[i])){
    count_final$Count[i] <- "OZ"
  } else if(is.na(count_final$Count[i])) {
    count_final$Count[i] <- "UNKNOWN"
  } else{
    count_final$Count[i] <- "COUNT"
  }
}
```

Logic:
- Contains "oz", "ounce", "ounces" → Unit = "OZ"
- Anything else (capsules, tablets, etc.) → Unit = "COUNT"
- No match → Unit = "UNKNOWN"

Example:
```
Count_numeric="60", Count="softgels" → Unit="COUNT"
Count_numeric="8", Count="fl oz" → Unit="OZ"
Count_numeric=NA → Unit="UNKNOWN"
```

14.2E Rename Columns:
```r
names(count_final)[2] <- "Count"
names(count_final)[3] <- "Unit Of Measurement"
```


14.3 STEP 3: FALLBACK SEARCH FOR UNKNOWNS (Lines 104-148)
----------------------------------------------------------

Products that didn't match primary pattern get a second chance!

14.3A Separate Unknowns:
```r
keep_looking <- subset(count_final, Count == "UNKNOWN")
count_final <- subset(count_final, Count != "UNKNOWN")
```

14.3B Alternative Regex for Weight Units:
```r
alt_count <- "(((\\d{1,4})|(\\d{1,2}\\.\\d{1,2})|(\\.\\d{1,2}))\\s*(lb|pounds|lbs|pound|kilo|kg|kgs|kilos|kilograms|mg|g|ml|millil))"
```

This catches:
- lb, lbs, pounds
- kg, kilos, kilograms  
- mg, g, ml

Example Matches:
```
"protein powder 2 lbs" → "2 lbs"
"vitamin c 500 mg" → "500 mg"
"creatine 5 g" → "5 g"
```

Note: These get caught here because they weren't in the primary pattern!

14.3C Keyword-Based Search (Lines 127-148):

If STILL no match, search around count keywords:

```r
for(i in 1:nrow(keep_looking2)){
  for(j in count_keywords[[1]]){  # loop through all 80+ unit keywords
    if(is.na(keep_looking2$Count[i]) && grepl(j, keep_looking2$Title[i])){
      loc1 <- str_locate(keep_looking2$Title[i], j)
      str1 <- substr(keep_looking2$Title[i], loc1-30, loc1+nchar(j))  # grab 30 chars before keyword
      splt_words <- rev(str_split(str1, ' ')[[1]])
      for(k in splt_words){
        if(grepl("[[:digit:]]", k)){  # find first number before keyword
          keep_looking2$Count_numeric[i] <- k
          keep_looking2$Count[i] <- 'COUNT'
          break()
        }
      }
    }
  }
}
```

Logic:
1. Find unit keyword (e.g., "capsules") in title
2. Look 30 characters BEFORE that keyword
3. Find the FIRST number working backwards
4. That's probably the count!

Example:
```
"nature's way multivitamin for adults with 60 capsules"
→ Finds "capsules"
→ Looks back 30 chars: "adults with 60 capsules"
→ Finds "60"
→ Count_numeric=60, Unit=COUNT
```


14.4 STEP 4: CONVERT ALL WEIGHT UNITS TO OZ (Lines 152-177)
------------------------------------------------------------

Goal: Standardize all weight measurements to ounces

```r
for(i in 1:nrow(keep_looking2)) {
  if(!is.na(keep_looking2$Count[i])){
    if (keep_looking2$Count[i] == "lb" || keep_looking2$Count[i] == "lbs" || 
        keep_looking2$Count[i] == "pound" || keep_looking2$Count[i] == "pounds") {
      keep_looking2$Count_numeric[i] = keep_looking2$Count_numeric[i] * 16
    } else if(keep_looking2$Count[i] == "g"){
      keep_looking2$Count_numeric[i] = keep_looking2$Count_numeric[i] * 0.035274
    } else if(keep_looking2$Count[i] == "mg"){
      keep_looking2$Count_numeric[i] = keep_looking2$Count_numeric[i] * 0.000035274
    } else if(keep_looking2$Count[i] == "kg" || keep_looking2$Count[i] == "kgs" || 
              keep_looking2$Count[i] == "kilos" || keep_looking2$Count[i] == "kilogram" || 
              keep_looking2$Count[i] == "kilograms"){
      keep_looking2$Count_numeric[i] = keep_looking2$Count_numeric[i] * 35.274
    } else if(keep_looking2$Count[i] == "ml" || keep_looking2$Count[i] == "millil"){
      keep_looking2$Count_numeric[i] = keep_looking2$Count_numeric[i] * 0.033814
    }
    
    if(keep_looking2$Count[i] != "COUNT"){
      keep_looking2$Count[i] = 'OZ'  # Change unit to OZ
    }
  }
}
```

Conversion Factors:
- 1 lb = 16 oz
- 1 g = 0.035274 oz
- 1 mg = 0.000035274 oz
- 1 kg = 35.274 oz
- 1 ml = 0.033814 oz (fluid)

Example:
```
Count=2, Unit="lbs" → Count=32, Unit="OZ"
Count=500, Unit="g" → Count=17.637, Unit="OZ"
Count=60, Unit="COUNT" → Count=60, Unit="COUNT" (no change)
```

Why Standardize to OZ?
- Easier to compare products
- Single unit for all weight-based measurements
- Industry standard for US supplement market


14.5 STEP 5: MERGE AND OUTPUT (Lines 179-204)
----------------------------------------------

```r
# Mark remaining NAs as UNKNOWN
for(i in 1:nrow(keep_looking2)){
  if(is.na(keep_looking2$Count[i])){
    keep_looking2$Count[i] <- "UNKNOWN"
  }
  if(is.na(keep_looking2$`Unit Of Measurement`[i])){
    keep_looking2$`Unit Of Measurement`[i] <- "UNKNOWN"
  }
}

# Combine both datasets (primary matches + fallback matches)
count_final = rbind(count_final, keep_looking2)

# Final output
ItemsPredictOutputCount <- tibble(RetailerSku = count_final$RetailerSku, 
                                  Count = count_final$Count, 
                                  `Unit Of Measurement` = count_final$`Unit Of Measurement`)

write.csv(ItemsPredictOutputCount, "./Outputs/count_update.csv")
```


14.6 OUTPUT
-----------

ItemsPredictOutputCount

Columns:
- RetailerSku
- Count (numeric value)
- Unit Of Measurement ("COUNT" or "OZ")

Example Output:
```
RetailerSku | Count   | Unit Of Measurement
B0001       | 60      | COUNT
B0002       | 180     | COUNT
B0003       | 8       | OZ
B0004       | 32      | OZ (converted from 2 lbs)
B0005       | UNKNOWN | UNKNOWN
```


14.7 EDGE CASES
---------------

CASE 1: Multiple Numbers in Title
----------------------------------

Example: "Vitamin D3 5000 IU 60 Softgels"

Flow:
- Regex matches FIRST occurrence: "60 Softgels"
- Result: Count=60, Unit=COUNT ✅

Note: "5000" is ignored (part of "5000 IU" dosage, not count)


CASE 2: No Count in Title
--------------------------

Example: "Daily Multivitamin Formula"

Flow:
1. Primary regex: No match
2. Fallback regex: No match
3. Keyword search: No "capsules", "tablets", etc. found
4. Result: Count=UNKNOWN, Unit=UNKNOWN

Manual Review Needed: Analyst must check product details/images


CASE 3: Weight-Based Products
------------------------------

Example: "Whey Protein Powder 2 lbs"

Flow:
1. Primary regex: No match (lbs not in primary pattern)
2. Fallback regex: Matches "2 lbs"
3. Conversion: 2 * 16 = 32
4. Result: Count=32, Unit=OZ ✅


CASE 4: Ambiguous Format
-------------------------

Example: "120 Count 500mg Capsules"

Flow:
- Regex matches: "120 Count"
- Result: Count=120, Unit=COUNT ✅


CASE 5: Decimal Counts
-----------------------

Example: "Fish Oil 1.5 oz"

Flow:
- Regex matches: "1.5 oz"
- Result: Count=1.5, Unit=OZ ✅


CASE 6: Bonus Packs
--------------------

Example: "60+30 Bonus Pack Capsules"

Preprocessing: "60+30" → "60plus30"
Regex: May extract "60plus30" or just "60"
Result: Varies - may need manual correction


CASE 7: Ingredient Numbers Confusion
-------------------------------------

Example: "CoQ10 Formula 100 Softgels"

Without preprocessing: "10" extracted as count (WRONG!)
With preprocessing: "CoQ10" → "COQTEN", "100" extracted (CORRECT!)

Result: Count=100, Unit=COUNT ✅


14.8 ACCURACY AND LIMITATIONS
------------------------------

Typical Success Rate: ~85-90%

High Accuracy Cases:
- Clear "[number] [unit]" format
- Standard unit names (capsules, tablets, oz)
- Single count/size in title

Low Accuracy Cases:
- Multiple counts in title (bonus packs)
- Non-standard formatting
- Missing count information entirely

Cannot Handle:
- Counts only in product images
- Counts only in description (not title)
- Ambiguous cases (e.g., "90 day supply")

Manual Review Needed For:
- Products with UNKNOWN count/unit
- Products with unusual formatting
- Bonus pack calculations


================================================================================
SECTION 15: BUSINESS RULES AFTER SCRIPT 5
================================================================================

No immediate business rules after Script 5.

Business rule involving Count comes AFTER Script 6 (Pack Size), where Count and Size may be swapped if Size ≥ 20.

See Section 17 for the Pack Size/Count QC business rule.


================================================================================
SECTION 16: STATE AFTER SCRIPT 5
================================================================================

At this point, each product has:
✅ RetailerSku
✅ Title
✅ Brand
✅ Primary ingredient (Script 1)
✅ other ing. 2, 3, 4... (Script 1)
✅ Category (Script 1 + business rules)
✅ Subcategory (Script 1 + business rules)
✅ Form (Script 2)
✅ Age (Script 3)
✅ Gender (Script 4)
✅ Count (Script 5)
✅ Unit Of Measurement (Script 5)

Still Missing:
❌ Size / Pack Size (Script 6)
❌ Health Focus (Script 7)
❌ Organic (post-processing)
❌ High Level Category (post-processing)

Next Steps:
- Script 6 (Pack Size Coding) will run - Also REGEX-based
- Business rule will check if Size/Count are swapped (Size ≥ 20)
- Script 7 (Health Focus) will run - XGBoost ML
- More business rules applied
- Final cleanup and export


================================================================================
SCRIPT 5 SUMMARY
================================================================================

What Script 5 Does:
1. ✅ Preprocesses title (replaces ingredient numbers to avoid confusion)
2. ✅ Uses regex to extract [NUMBER] [UNIT] patterns
3. ✅ Categorizes units as COUNT or OZ
4. ✅ Fallback search for missed items (weight units, keyword search)
5. ✅ Converts all weight units to OZ (lb, g, kg, mg, ml → oz)
6. ✅ Marks unmatched items as UNKNOWN

Outputs:
- Count (numeric value)
- Unit Of Measurement (COUNT or OZ)

Method:
- REGEX pattern matching (NOT ML!)
- 80+ unit keyword variations
- Multi-pass search (primary + fallback)
- Unit conversion for standardization

Success Rate: ~85-90%

Limitations:
- Can only extract from title (not description/images)
- May confuse multiple numbers in title
- Cannot handle ambiguous cases
- Requires manual review for UNKNOWN values

Method Comparison:
- Script 1 (Ingredients): Rule-based lookup (960 lines)
- Scripts 2-4 (Form/Age/Gender): Random Forest ML
- Script 5 (Count): REGEX pattern matching (207 lines)
- Script 6 (Pack Size): REGEX pattern matching (coming next)
- Script 7 (Health Focus): XGBoost ML (coming next)


================================================================================
END OF SCRIPT 5 DOCUMENTATION
================================================================================


================================================================================
SECTION 17: SCRIPT 6 - PACK SIZE FINAL.R
================================================================================

Purpose: Extract Size (Pack Size / number of packages)
Method: REGEX PATTERN MATCHING (simpler than Script 5)
Input: df_test (RetailerSku, Title, Brand)
Output: Size

Note: Much simpler than Script 5 - only 63 lines!


17.1 STEP 1: TEXT PREPROCESSING (Lines 20-26)
----------------------------------------------

Very minimal preprocessing (simpler than Script 5):

```r
df_test_pack$Title <- str_replace_all(df_test_pack$Title, '\\+', "plus")  # "+" → "plus"
df_test_pack$Title <- str_replace_all(df_test_pack$Title, '\\&', "and")   # "&" → "and"
df_test_pack$Title <- str_replace_all(df_test_pack$Title, '\\-', " ")     # "-" → space
```

Why minimal? Pack size patterns are simpler and less prone to confusion.

Example:
```
Before: "2-Pack Multivitamin"
After:  "2 Pack Multivitamin"
```


17.2 STEP 2: PACK SIZE REGEX EXTRACTION (Lines 32-48)
------------------------------------------------------

17.2A Define Pack Pattern:
```r
pack_pattern <- "((\\d{1,3}\\s*(pk|pks|pack|packs|package|packages|bottle|bottles)(?!\\w))|(pack of|case of|)\\s*\\d{1,3})"
```

What It Finds:

Pattern 1: [NUMBER] [PACK_KEYWORD]
- Keywords: pk, pks, pack, packs, package, packages, bottle, bottles
- Example: "2 pack", "3 bottles", "4 packs"

Pattern 2: [PACK_KEYWORD] [NUMBER]
- Keywords: "pack of", "case of"
- Example: "pack of 2", "case of 6"

The (?!\\w) ensures no letters immediately follow (avoids matching "packer", "packages")

17.2B Extract All Matches:
```r
test_pack <- str_extract_all(df_test_pack$Title, pack_pattern, simplify=TRUE)
```

Note: Uses str_extract_all (finds ALL matches), not str_extract (first match only)

Example Extractions:
```
"2 pack fish oil 180 capsules" → "2 pack"
"pack of 3 vitamin d" → "pack of 3"
"daily multivitamin 60 tablets" → NO MATCH
"4 bottles vitamin c" → "4 bottles"
```

17.2C Extract Numeric Part:
```r
pack_numeric <- str_extract(test_pack2[,3], "[[:digit:]]+")
```

Example:
```
"2 pack" → "2"
"pack of 3" → "3"
"4 bottles" → "4"
```


17.3 STEP 3: DEFAULT TO 1 (Lines 56-60)
----------------------------------------

```r
pack_final[is.na(pack_final)] <- 1
```

Logic: If no pack size found, assume it's a SINGLE UNIT (Size = 1)

Why This Makes Sense:
- Most products are sold individually
- Pack size is usually explicitly stated if > 1
- Default assumption: 1 package

Example:
```
"vitamin d 5000 iu 60 softgels" → NO MATCH → Size = 1 (default)
"2 pack vitamin d 5000 iu" → MATCH → Size = 2
```


17.4 OUTPUT (Line 60)
---------------------

```r
ItemsPredictOutputPackSize <- tibble(RetailerSku = pack_final$RetailerSku, 
                                     Size = pack_final$pack_numeric)
```

ItemsPredictOutputPackSize

Columns:
- RetailerSku
- Size (pack size number)

Example Output:
```
RetailerSku | Size
B0001       | 1
B0002       | 2
B0003       | 3
B0004       | 1
B0005       | 6
```


17.5 EDGE CASES
---------------

CASE 1: No Pack Size Mentioned
-------------------------------

Example: "Nature's Way Vitamin D 5000 IU 60 Softgels"

Flow:
- No "pack", "packs", "bottles" keywords found
- Result: Size = 1 (default) ✅


CASE 2: Explicit Pack Size
---------------------------

Example: "Nature's Way Vitamin D 2 Pack"

Flow:
- Matches "2 Pack"
- Extracts "2"
- Result: Size = 2 ✅


CASE 3: "Pack Of" Format
-------------------------

Example: "Fish Oil Pack of 3"

Flow:
- Matches "Pack of 3"
- Extracts "3"
- Result: Size = 3 ✅


CASE 4: Multiple Bottles
-------------------------

Example: "Multivitamin 4 Bottles"

Flow:
- Matches "4 Bottles"
- Extracts "4"
- Result: Size = 4 ✅


CASE 5: Ambiguous "Pack" Reference
-----------------------------------

Example: "Travel Pack Size Multivitamin 30 Capsules"

Flow:
- "Travel Pack Size" might match as "Pack"
- But no number immediately before/after "pack"
- Result: May extract incorrectly or miss

Limitation: Simple regex can be confused by descriptive uses of "pack"


CASE 6: Value Pack / Bonus Pack
--------------------------------

Example: "60+30 Bonus Pack Softgels"

Flow:
- "60plus30 Bonus Pack" (after preprocessing)
- Might match "Bonus Pack" but numeric extraction may fail
- Result: Likely Size = 1 (default)

Note: This is actually a count issue (90 total capsules), not a pack size issue


CASE 7: Bulk Case Sizes
------------------------

Example: "Vitamin C Case of 24"

Flow:
- Matches "Case of 24"
- Extracts "24"
- Result: Size = 24

Note: This will trigger the Pack Size/Count QC business rule (next section)


================================================================================
SECTION 18: BUSINESS RULE - PACK SIZE/COUNT QC (FinalMerge.R Lines 286-293)
================================================================================

Purpose: Fix confusion between Pack Size and Count

This rule runs AFTER both Script 5 (Count) and Script 6 (Size) complete.


18.1 THE PROBLEM
----------------

Comment in R code states:
"SIZE AND COUNT ARE INCORRECT THROUGHOUT THE CODE, SWAPPED EN POST"

Meaning:
- Sometimes regex extracts the wrong value
- A "Size" of 60 is probably "Count" (60 capsules), not 60 packages!
- Need to swap them based on heuristic


18.2 THE BUSINESS RULE
-----------------------

```r
# Pack size override - if pack size >= 20, it's likely actually a count
for (i in 1:nrow(new_items)){
  if(new_items$Size[i] > 19 && !is.na(new_items$Size[i])){
    new_items$Count[i] <- new_items$Size[i]  # Move Size to Count
    new_items$Size[i] <- 1                    # Reset Size to 1
  }
}
```

Logic:
IF Size ≥ 20 (and not NA):
  - Move Size value to Count
  - Set Size = 1


18.3 WHY THIS RULE EXISTS
--------------------------

Real-World Product Patterns:

Typical Pack Sizes: 1, 2, 3, 4, 6, 12 (rarely > 20)
- Single unit (most common)
- Twin pack, 3-pack, family pack
- Occasionally 6-pack or 12-pack
- Very rarely 20+ packs

Typical Counts: 30, 60, 90, 120, 180, 240+ capsules/tablets
- Standard supplement bottle sizes
- Frequently 60 or higher

Heuristic: If Size ≥ 20, it's almost certainly a misidentified Count!


18.4 EXAMPLE TRANSFORMATIONS
-----------------------------

Example 1 - Correction Needed:
------------------------------

Title: "Vitamin D 5000 IU 60 Count Softgels"

Script 5 (Count): Misses "60 count" → Count = UNKNOWN
Script 6 (Pack Size): Matches "60 count" → Size = 60 (WRONG - regex confused "count" with "pack")

Business Rule:
- Size = 60 > 19
- Count = 60 (moved from Size)
- Size = 1

Result: Count=60, Size=1 ✅ (CORRECTED!)


Example 2 - No Change Needed:
------------------------------

Title: "Multivitamin 180 Capsules 2 Pack"

Script 5: Count = 180, Unit = COUNT
Script 6: Size = 2

Business Rule:
- Size = 2 < 20
- No change

Result: Count=180, Size=2 ✅ (CORRECT!)


Example 3 - Single Unit Product:
---------------------------------

Title: "Fish Oil 1000mg 60 Softgels"

Script 5: Count = 60, Unit = COUNT
Script 6: Size = 1 (default - no pack mentioned)

Business Rule:
- Size = 1 < 20
- No change

Result: Count=60, Size=1 ✅ (CORRECT!)


Example 4 - Legitimate Large Pack (EDGE CASE):
-----------------------------------------------

Title: "Vitamin C 500mg 30 Tablets (20-Pack)"

Script 5: Count = 30, Unit = COUNT
Script 6: Size = 20

Business Rule:
- Size = 20 ≥ 20 (threshold triggered!)
- Count = 20 (moved from Size) ❌ WRONG!
- Size = 1

Result: Count=20, Size=1 (INCORRECT - was actually 30 tablets × 20 packs = 600 total)

Limitation: This heuristic fails on legitimate bulk purchases (20+ pack sizes).

However: These are VERY RARE in the supplement market. Most bulk sales are 2-12 packs.


Example 5 - Case Pack Misidentified:
-------------------------------------

Title: "Protein Bar Case of 24"

Script 5: Count = UNKNOWN (no capsule/tablet keywords)
Script 6: Size = 24 (matched "Case of 24")

Business Rule:
- Size = 24 > 19
- Count = 24 (moved from Size)
- Size = 1

Result: Count=24, Size=1

Is this correct? Maybe - depends if "Case of 24" means:
- 24 bars total (Count=24, Size=1) ✅
- 24 boxes of bars (Count=?, Size=24) ❌

Ambiguous case - may require manual review.


18.5 WHEN THE RULE HELPS
-------------------------

High Success Cases:
- Products where Script 6 incorrectly extracts count as size
- Title has "60 count", "90 ct", "120 capsules" but regex confused it
- Script 5 missed it, Script 6 caught it but in wrong column

Result: Business rule correctly swaps them


18.6 WHEN THE RULE FAILS
-------------------------

Failure Cases:
- Legitimate bulk packs (20+, 24-pack, etc.)
- Wholesale/club store packs
- Case quantities

Result: Rule incorrectly swaps valid pack size to count

But these are RARE, so acceptable trade-off.


18.7 ACCURACY IMPACT
---------------------

Before Business Rule:
- ~85% accuracy on Count
- ~90% accuracy on Size
- But occasional obvious swaps (Size=60, Count=UNKNOWN)

After Business Rule:
- ~88% accuracy on Count (improved)
- ~89% accuracy on Size (slight decrease for edge cases)
- Fewer obviously wrong values

Trade-off: Fixes common errors at cost of rare edge case errors


================================================================================
SECTION 19: STATE AFTER SCRIPTS 5 & 6
================================================================================

At this point, each product has:
✅ RetailerSku
✅ Title
✅ Brand
✅ Primary ingredient (Script 1)
✅ other ing. 2, 3, 4... (Script 1)
✅ Category (Script 1 + business rules)
✅ Subcategory (Script 1 + business rules)
✅ Form (Script 2)
✅ Age (Script 3)
✅ Gender (Script 4)
✅ Count (Script 5 + Pack Size QC swap)
✅ Unit Of Measurement (Script 5)
✅ Size (Script 6 + Pack Size QC swap)

Still Missing:
❌ Health Focus (Script 7)
❌ Organic (post-processing)
❌ High Level Category (post-processing)

Next Steps
- Script 7 (Health Focus) will run - XGBoost ML (different from Random Forest!)
- More business rules applied
- Final cleanup and export


================================================================================
SCRIPTS 5-6 SUMMARY (COUNT AND PACK SIZE)
================================================================================

What Scripts 5 & 6 Do:
1. ✅ Both use REGEX pattern matching (NOT ML)
2. ✅ Script 5 is complex (207 lines, multi-pass, unit conversion)
3. ✅ Script 6 is simple (63 lines, single pattern, default to 1)
4. ✅ Both work independently from same input (df_test)
5. ✅ Business rule swaps Size→Count if Size ≥ 20

Outputs:
- Script 5: Count (numeric), Unit Of Measurement (COUNT or OZ)
- Script 6: Size (pack size number)

Business Rule Using These:
- Pack Size/Count QC: If Size ≥ 20 → swap to Count, set Size=1

Method Differences:
- Script 5: Multi-pass regex (primary + fallback + keyword search), unit conversion
- Script 6: Single-pass regex, simple default to 1

Success Rates:
- Count: ~88% (after business rule correction)
- Size: ~89% (after business rule correction)

Limitations:
- Can only extract from title (not description/images)
- Simple heuristic (≥20 threshold) can fail on bulk packs
- Ambiguous cases require manual review

Method Comparison So Far:
- Script 1 (Ingredients): Rule-based lookup (960 lines)
- Scripts 2-4 (Form/Age/Gender): Random Forest ML
- Scripts 5-6 (Count/Size): REGEX pattern matching
- Script 7 (Health Focus): XGBoost ML (coming next - different ML method!)


================================================================================
END OF SCRIPTS 5-6 DOCUMENTATION
================================================================================


================================================================================
SECTION 20: SCRIPT 7 - HF_JF1.R (HEALTH FOCUS)
================================================================================

Purpose: Predict Health Focus (what health benefit the supplement targets)
Method: XGBOOST ML MODEL (different from Random Forest used in Scripts 2-4!)
Input: df_test (RetailerSku, Title, Brand)
Output: Health Focus (one of 20 categories, or NA if uncertain)

Key Difference: XGBoost vs Random Forest, uses confidence threshold, returns probabilities


20.1 WHAT IS XGBOOST VS RANDOM FOREST?
---------------------------------------

Scripts 2-4 (Form/Age/Gender): Random Forest
- Tokenize → Remove stop words → Stem → DTM
- Use 22-42 tokens
- No confidence scores

Script 7 (Health Focus): XGBoost
- Count word occurrences directly (no stemming/stop word removal)
- Use 1000+ terms (frequent words from training data)
- Returns probability scores for each health focus category
- Uses 30% confidence threshold
- More sophisticated ML algorithm


20.2 THE 20 HEALTH FOCUS CATEGORIES
------------------------------------

1. BEAUTY
2. BLOOD SUGAR SUPPORT
3. BONE HEALTH
4. BRAIN HEALTH
5. CARDIOVASCULAR HEALTH
6. CLEANSE & DETOX
7. COUGH, COLD & FLU
8. DAILY IMMUNE HEALTH
9. DIGESTIVE HEALTH
10. ENERGY SUPPORT
11. EYE HEALTH
12. GENERAL HEALTH
13. JOINT HEALTH
14. MEN'S HEALTH
15. MOOD & STRESS SUPPORT
16. PAIN & INFLAMMATION
17. SLEEP
18. URINARY TRACT HEALTH
19. WEIGHT MANAGEMENT
20. WOMEN'S HEALTH


20.3 STEP 1: PREPROCESSING - REMOVE BRAND (Lines 14-21)
--------------------------------------------------------

```r
test_df_health <- df_test

# Remove brand name from title
for(i in 1:nrow(test_df_health)){
  if(!is.na(test_df_health$Brand[i]) && grepl(test_df_health$Brand[i], test_df_health$Title[i])){
    test_df_health$Title[i] <- gsub(test_df_health$Brand[i], '', test_df_health$Title[i])
  }
}
```

Why? Brand names don't indicate health focus.

Example:
```
Before: "Nature's Way Vitamin D for Bone Health"
After:  " Vitamin D for Bone Health"
```


20.4 STEP 2: CREATE WORD COUNT MATRIX (Lines 25-40)
----------------------------------------------------

20.4A Load Frequent Terms (1000+ words):
```r
ft <- jsonlite::fromJSON("./Data/terms.json")[[1]]
unique_hf <- jsonlite::fromJSON("./Data/unique_hf.json")[[1]]
```

Frequent terms are the most common words across all health focus categories in training data.

Examples: "collagen", "joint", "support", "bone", "cardiovascular", "energy", "immune", 
"sleep", "probiotic", "brain", "mood", "stress", "beauty", "hair", "skin", etc.

20.4B Create Empty Matrix:
```r
test_dtm_df <- data.frame(matrix(rep(0, len=nrow(test_df_health)*length(ft)), 
                                 nrow=nrow(test_df_health)))
colnames(test_dtm_df) <- ft
```

Creates a matrix:
- Rows = products
- Columns = 1000+ terms
- Initial values = 0

20.4C Count Word Occurrences:
```r
for(i in ft){
  test_dtm_df[,i] <- str_count(test_df_health$Title, i)
}
```

Count how many times each term appears in each title (no stemming, direct count).

Example:
```
Title: "joint support with collagen and turmeric for joint health"

Term counts:
- joint: 2
- support: 1
- collagen: 1
- turmeric: 1
- health: 1
- (all other 1000+ terms: 0)
```

20.4D Convert to XGBoost Format:
```r
xgtest <- xgb.DMatrix(data=as.matrix(test_dtm_df), missing=NA)
```


20.5 STEP 3: RUN XGBOOST MODEL (Lines 45-62)
---------------------------------------------

20.5A Load Model:
```r
test_gbdt <- xgb.load('./FinalModels/xgb_JF1.model')
```

20.5B Predict:
```r
test_results <- predict(test_gbdt, xgtest)
```

20.5C Convert to Probability Matrix:
```r
pred_matrix <- as.data.frame(matrix(test_results, ncol=length(unique_hf), byrow=T))
colnames(pred_matrix) <- unique_hf
```

Result: Each product gets a probability score (0-1) for EACH of the 20 health focus categories!

Example Probability Matrix:
```
Product A:
- JOINT HEALTH: 0.85
- PAIN & INFLAMMATION: 0.12
- BONE HEALTH: 0.02
- (all others: <0.01)
```


20.6 STEP 4: APPLY CONFIDENCE THRESHOLD (Lines 66-75)
------------------------------------------------------

```r
pred_class <- rep(NA, nrow(test_df_health))

for(i in 1:nrow(pred_matrix)){
  if(max(pred_matrix[i, 1:length(unique_hf)]) > 0.30){
    pred_class[i] <- which.max(pred_matrix[i, 1:length(unique_hf)])
  }
}
```

Logic:
- IF max probability > 30% (0.30 threshold)
  - THEN: Assign that health focus
- ELSE: Leave as NA (uncertain)

Why 30% Threshold?
- Avoids low-confidence guesses
- If model is uncertain, better to have NA than wrong classification
- NA will be filled later by business rules

Example:
```
Product A: Max = 0.85 (JOINT HEALTH) > 0.30 → Assign "JOINT HEALTH" ✅
Product B: Max = 0.25 (GENERAL HEALTH) < 0.30 → Assign NA (uncertain) ✅
Product C: Max = 0.45 (SLEEP) > 0.30 → Assign "SLEEP" ✅
```


20.7 STEP 5: FINALIZE OUTPUT (Lines 82-106)
--------------------------------------------

```r
final_results <- data.frame('RetailerSku'=test_df_health$RetailerSku)
final_results <- cbind(final_results, pred_matrix)

# Convert class index to actual health focus name
final_results$`Health Focus` <- NA
for(i in 1:nrow(final_results)){
  final_results$`Health Focus`[i] <- unique_hf[pred_class[i]]
}

# Write full results (with all 20 probability scores)
write.csv(final_results, paste('./Outputs/Alt Full Lists/hf_full_', currentDate, '.csv', sep=""))

# Create output for final merge (SKU + Health Focus only)
ItemsPredictOutputHF <- tibble(RetailerSku=final_results$RetailerSku, 
                               `Health Focus`=final_results$`Health Focus`)
```

Two Outputs:
1. Full results (with all 20 probability scores) - saved for later analysis
2. Simple output (SKU + Health Focus) - used in final merge


20.8 OUTPUT
-----------

ItemsPredictOutputHF

Columns:
- RetailerSku
- Health Focus (one of 20 categories, or NA)

Example Output:
```
RetailerSku | Health Focus
B0001       | JOINT HEALTH
B0002       | CARDIOVASCULAR HEALTH
B0003       | SLEEP
B0004       | NA (below confidence threshold)
B0005       | WOMEN'S HEALTH
```


20.9 EDGE CASES
---------------

CASE 1: Clear Health Focus Keywords
------------------------------------

Example: "Glucosamine Chondroitin for Joint Health Support"

Words: joint=1, support=1, health=1, glucosamine=1, chondroitin=1

Prediction: JOINT HEALTH (high confidence ~85%)
Result: Health Focus = "JOINT HEALTH" ✅


CASE 2: Multiple Possible Health Focus
---------------------------------------

Example: "Turmeric Curcumin for Joint Pain and Inflammation"

Words: turmeric=1, joint=1, pain=1, inflammation=1

Model scores:
- PAIN & INFLAMMATION: 0.48
- JOINT HEALTH: 0.45

Prediction: PAIN & INFLAMMATION (highest score > 0.30)
Result: Health Focus = "PAIN & INFLAMMATION" ✅


CASE 3: Generic Multivitamin
-----------------------------

Example: "Daily Multivitamin for Adults"

Words: daily=1, multivitamin=1, adult=1

Model scores:
- GENERAL HEALTH: 0.28
- DAILY IMMUNE HEALTH: 0.22
- (all others < 0.20)

Prediction: Max = 0.28 < 0.30 threshold
Result: Health Focus = NA (will be filled by business rules later) ✅


CASE 4: No Health Focus Keywords
---------------------------------

Example: "Vitamin D3 5000 IU"

Words: vitamin=1, d=1

Model uncertain - no clear health focus indicators
Result: Health Focus = NA (will be filled by business rules) ✅


CASE 5: Women's Prenatal
-------------------------

Example: "Prenatal Multivitamin with DHA for Women"

Words: prenatal=1, multivitamin=1, women=1, dha=1

Prediction: WOMEN'S HEALTH (high confidence ~0.75)
Result: Health Focus = "WOMEN'S HEALTH" ✅


================================================================================
SECTION 21: BUSINESS RULES AFTER SCRIPT 7 (EXTENSIVE!)
================================================================================

Health Focus has THE MOST business rules of any attribute!

There are 6 major rule sections:
1. NA Fill from Ingredient Lookup
2. Old → New HF Taxonomy Mapping
3. Vitamin D Override
4. 50+ Keyword-Based Overrides
5. Gender-Based Correction (already documented)
6. Multivitamin → General Health


21.1 RULE 1: FILL NA FROM INGREDIENT LOOKUP (Lines 302-329)
------------------------------------------------------------

Purpose: Use ingredient as fallback when title-based model fails

```r
# Load ingredient → health focus mapping
lookup_df <- read.csv("./Data/hf_lookup.csv")

# Merge with main data
new_items <- merge(x=new_items, y=lookup_df, by='Functional Ingredient', all.x=T)

# Fill NA health focus with lookup value
new_items[is.na(new_items$`Health Focus`), 'Health Focus'] = 
  new_items[is.na(new_items$`Health Focus`), 'Focus']

# Remove temporary column
new_items$Focus <- NULL

# Convert to uppercase
new_items$`Health Focus` <- toupper(new_items$`Health Focus`)

# Handle #N/A values
if (any(grepl('#N/A', new_items$`Health Focus`))) {
  new_items[grepl('#N/A', new_items$`Health Focus`), ]$`Health Focus` <- 'HEALTH FOCUS - NON SPECIFIC'
}

# Default remaining NAs
new_items$`Health Focus`[is.na(new_items$`Health Focus`)] <- 'HEALTH FOCUS - NON SPECIFIC'
```

Why This Exists:
- Title-based model (Script 7) works on title keywords
- If title is vague, model is uncertain (NA)
- But ingredient itself often implies health focus!
- Glucosamine → Joint Health
- Vitamin D → Bone Health
- Melatonin → Sleep
- Cranberry → Urinary Tract Health

Example 1:
```
Product: "Glucosamine 1500mg Tablets"
Script 7: NA (no "joint" keywords in title)
Functional Ingredient: "GLUCOSAMINE"
Ingredient Lookup: GLUCOSAMINE → "JOINT HEALTH"
Result: Health Focus = "JOINT HEALTH" ✅
```

Example 2:
```
Product: "Super Green Formula Advanced"
Script 7: NA (uncertain)
Functional Ingredient: "UNKNOWN"
Ingredient Lookup: No match
Default: "HEALTH FOCUS - NON SPECIFIC"
Result: "HEALTH FOCUS - NON SPECIFIC"
```


21.2 RULE 2: OLD → NEW TAXONOMY MAPPING (Lines 356-369)
--------------------------------------------------------

Purpose: Remap OLD taxonomy names to NEW taxonomy (2022 reorganization)

Important: This remaps ALL THREE: Health Focus, Category, AND Subcategory!

Important Note from Code:
"This snippet will only be necessary until the nw HF algo is trained"
"This is the Quick and Dirty workaround for the reorg that happened in 2/2022"

```r
# Load TWO separate lookup tables
hf_transform  <- fread("./Data/MI Lookup.csv", select=c("Old HF", "New HF"))
cat_transform <- fread("./Data/MI Lookup.csv", select=c("Key", "New Category", "New Subcategory"))

# Create key from current Category + Subcategory
new_items$key <- paste(new_items$Category, new_items$Subcategory, sep="-")

# MAPPING 1: Old Health Focus → New Health Focus
HF_with_key_assignment <- lapply(new_items$`Health Focus`, 
  function(x) hf_transform$`New HF`[match(x, hf_transform$`Old HF`)])
new_items$`Health Focus` <- as.character(HF_with_key_assignment)

# MAPPING 2: Old Category → New Category
Category_with_key_assignment <- lapply(new_items$key, 
  function(x) cat_transform$`New Category`[match(x, cat_transform$Key)])
new_items$Category <- as.character(Category_with_key_assignment)

# MAPPING 3: Old Subcategory → New Subcategory
new_items$Subcategory <- lapply(new_items$key, 
  function(x) cat_transform$`New Subcategory`[match(x, cat_transform$Key)])
new_items$Subcategory <- as.character(new_items$Subcategory)
```

Why This Exists:
- In February 2022, company reorganized their ENTIRE taxonomy
- Health Focus categories renamed (XGBoost model still uses old names)
- Category names changed (Script 1 ingredient lookup uses old names)
- Subcategory names changed (Script 1 ingredient lookup uses old names)
- Rather than update all data sources and retrain models, they added mapping layer
- This is a TEMPORARY workaround

What Gets Remapped:

1. Health Focus (from Script 7):
   - XGBoost model outputs OLD health focus names
   - Mapped to NEW health focus names
   
2. Category (from Script 1):
   - Ingredient lookup assigns OLD category names
   - Mapped to NEW category names
   
3. Subcategory (from Script 1):
   - Ingredient lookup assigns OLD subcategory names
   - Mapped to NEW subcategory names

IMPORTANT: These are INDEPENDENT mappings!
- Health Focus mapping uses "Old HF" → "New HF" lookup
- Category/Subcategory mapping uses "Category-Subcategory pair" → "New Category + New Subcategory" lookup
- They are NOT correlated with each other

Example Mappings:
```
Health Focus:
OLD: "IMMUNE SUPPORT" → NEW: "DAILY IMMUNE HEALTH"
OLD: "STRESS RELIEF" → NEW: "MOOD & STRESS SUPPORT"

Category-Subcategory:
OLD: "BONE & JOINT-JOINT SUPPORT" → NEW: Category="JOINT HEALTH", Subcategory="JOINT SUPPORT"
OLD: "VITAMINS-SINGLE VITAMINS" → NEW: Category="SINGLE VITAMINS", Subcategory="SINGLE VITAMINS"
```

Example Product Flow:
```
BEFORE Mapping (OLD taxonomy):
Ingredient: "GLUCOSAMINE" (Script 1)
Category: "BONE & JOINT" (old name from ingredient lookup)
Subcategory: "JOINT SUPPORT" (old name from ingredient lookup)
Health Focus: "JOINT HEALTH" (Script 7 model prediction, old name)

AFTER Mapping (NEW taxonomy):
Category: "JOINT HEALTH" (remapped based on Category-Subcategory pair)
Subcategory: "JOINT SUPPORT" (remapped based on Category-Subcategory pair)
Health Focus: "JOINT HEALTH" (remapped, happens to be same name)
```

Note: Category/Subcategory can be remapped even if Health Focus is NA!
```
Product with NA Health Focus:
Category: "BONE & JOINT" → "JOINT HEALTH" (still remapped ✓)
Subcategory: "JOINT SUPPORT" → "JOINT SUPPORT" (still remapped ✓)
Health Focus: NA → NA (no mapping needed, stays NA)
```


21.3 RULE 3: VITAMIN D OVERRIDE (Lines 377-381)
------------------------------------------------

Purpose: Always assign Vitamin D products to BONE HEALTH

```r
for (i in 1:nrow(new_items)){
  if(new_items$`Functional Ingredient`[i] == "VITAMIN D" && 
     !is.na(new_items$`Functional Ingredient`[i])){
    new_items$`Health Focus`[i] <- "BONE HEALTH"
  }
}
```

Why:
- Vitamin D is primarily used for bone health (calcium absorption)
- Model might predict other health focuses
- Override all Vitamin D to BONE HEALTH (business decision)

Example:
```
Product: "Vitamin D3 5000 IU for Immune Support"
Script 7: Might predict "DAILY IMMUNE HEALTH"
Functional Ingredient: "VITAMIN D"
Override: Health Focus = "BONE HEALTH" (overrides model!)
```


21.4 RULE 4: 50+ KEYWORD-BASED OVERRIDES (Lines 455-631)
---------------------------------------------------------

Purpose: Override model predictions based on specific title keywords

This is THE LARGEST section of business rules!

21.4A High Priority Keywords (Lines 456-516):

```r
if (grepl("COUGH", new_items$Title[i])){
  new_items$`Health Focus`[i] = "COUGH, COLD & FLU"
}
if (grepl("MELATONIN", new_items$Title[i])){
  new_items$`Health Focus`[i] = "SLEEP"
}
if (grepl("TESTOSTERONE", new_items$Title[i])){
  new_items$`Health Focus`[i] = "MEN'S HEALTH"
}
if (grepl("MALE ENHANCEMENT", new_items$Title[i])){
  new_items$`Health Focus`[i] = "MEN'S HEALTH"
}
if (grepl("ESTROGEN", new_items$Title[i])){
  new_items$`Health Focus`[i] = "WOMEN'S HEALTH"
}
if (grepl("MENOPAUSE", new_items$Title[i])){
  new_items$`Health Focus`[i] = "WOMEN'S HEALTH"
}
if (grepl("PMS", new_items$Title[i])){
  new_items$`Health Focus`[i] = "WOMEN'S HEALTH"
}
```

21.4B Ingredient-Based Rules (Lines 484-509):

```r
if (new_items$`Functional Ingredient`[i]=="CALCIUM" && !is.na(...)){
  new_items$`Health Focus`[i] = "BONE HEALTH"
}
if (new_items$`Functional Ingredient`[i]=="CRANBERRY SUPPLEMENTS" && !is.na(...)){
  new_items$`Health Focus`[i] = "URINARY TRACT HEALTH"
}
if (new_items$`Functional Ingredient`[i]=="BLACK SEED (CUMIN)" && !is.na(...)){
  new_items$`Health Focus`[i] = "DAILY IMMUNE HEALTH"
}
if (new_items$`Functional Ingredient`[i]=="MAGNESIUM" && !is.na(...)){
  if (grepl("MOOD", new_items$Title[i]) || grepl("STRESS", new_items$Title[i])){
    new_items$`Health Focus`[i] = "MOOD & STRESS SUPPORT"
  }
}
```

21.4C Anatomical/Symptom Keywords (Lines 498-588):

```r
if (grepl("PROSTATE", new_items$Title[i])){
  new_items$`Health Focus`[i] = "URINARY TRACT HEALTH"
}
if (grepl("BLADDER", new_items$Title[i])){
  new_items$`Health Focus`[i] = "URINARY TRACT HEALTH"
}
if (grepl("BLOOD SUGAR", new_items$Title[i])){
  new_items$`Health Focus`[i] = "BLOOD SUGAR SUPPORT"
}
if (grepl("GLUCOSE", new_items$Title[i])){
  new_items$`Health Focus`[i] = "BLOOD SUGAR SUPPORT"
}
if (grepl("DIABETES", new_items$Title[i])){
  new_items$`Health Focus`[i] = "BLOOD SUGAR SUPPORT"
}
if (grepl("ARTHRITIS", new_items$Title[i])){
  new_items$`Health Focus`[i] = "JOINT HEALTH"
}
if (grepl("ACID REFLUX", new_items$Title[i])){
  new_items$`Health Focus`[i] = "DIGESTIVE HEALTH"
}
if (grepl("HEARTBURN", new_items$Title[i])){
  new_items$`Health Focus`[i] = "DIGESTIVE HEALTH"
}
if (grepl("LAXATIVE", new_items$Title[i])){
  new_items$`Health Focus`[i] = "DIGESTIVE HEALTH"
}
```

21.4D Special Logic Rules (Lines 589-614):

Joint Health + Collagen + Beauty Keywords:
```r
if (new_items$`Health Focus`[i] == "JOINT HEALTH"){
  if (grepl("COLLAGEN", new_items$Title[i])){
    if (grepl("BEAUTY", new_items$Title[i]) || 
        grepl("HAIR", new_items$Title[i]) ||
        grepl("SKIN ", new_items$Title[i]) ||
        grepl("NAILS", new_items$Title[i])){
      new_items$`Health Focus`[i] = "BEAUTY"
    }
  }
}
```

Logic: Collagen can be for joints OR beauty - if beauty keywords present, switch to BEAUTY

Brain Health Rules:
```r
if (grepl("MCT OIL", new_items$Title[i])){
  new_items$`Health Focus`[i] = "BRAIN HEALTH"
}
if (grepl("KRILL OIL", new_items$Title[i])){
  new_items$`Health Focus`[i] = "BRAIN HEALTH"
}
if (grepl("DHA", new_items$Title[i])){
  new_items$`Health Focus`[i] = "BRAIN HEALTH"
}
```

21.4E Low Confidence Fallback Rules (Lines 617-630):

Only apply if current Health Focus is "HEALTH FOCUS NON-SPECIFIC":

```r
if(new_items$`Health Focus`[i] == "HEALTH FOCUS NON-SPECIFIC"){
  if (grepl("ANTIOXIDANT", new_items$Title[i])){
    new_items$`Health Focus`[i] = "DAILY IMMUNE HEALTH"
  }
  if (grepl("COLON", new_items$Title[i])){
    new_items$`Health Focus`[i] = "CLEANSE & DETOX"
  }
  if (grepl("LIVER", new_items$Title[i])){
    new_items$`Health Focus`[i] = "CLEANSE & DETOX"
  }
  if (grepl("NAUSEA", new_items$Title[i])){
    new_items$`Health Focus`[i] = "DIGESTIVE HEALTH"
  }
}
```

Why: These keywords are less specific, only use as last resort


21.5 RULE 5: GENDER-BASED CORRECTION (Lines 634-640)
-----------------------------------------------------

Already documented in Section 12!

```r
if(new_items$`Health Focus`[i] == "MEN'S HEALTH" && 
   new_items$`Gender`[i] == "GENDER - FEMALE"){
  new_items$`Health Focus`[i] <- "WOMEN'S HEALTH"
}
else if(new_items$`Health Focus`[i] == "WOMEN'S HEALTH" && 
        new_items$`Gender`[i] == "GENDER - MALE"){
  new_items$`Health Focus`[i] <- "MEN'S HEALTH"
}
```


21.6 RULE 6: MULTIVITAMIN → GENERAL HEALTH (Lines 643-650)
-----------------------------------------------------------

Purpose: Assign specific health focus to multivitamins, convert other "general health" to non-specific

```r
for (i in 1:nrow(new_items)){
  if(new_items$Category[i] == "COMBINED MULTIVITAMINS" && !is.na(...)){
    new_items$`Health Focus`[i] <- "GENERAL HEALTH"
  }
  else if(new_items$`Health Focus`[i] == "GENERAL HEALTH" && !is.na(...)){
    new_items$`Health Focus`[i] <- "HEALTH FOCUS NON-SPECIFIC"
  }
}
```

Logic:
- IF Category = "COMBINED MULTIVITAMINS" → Health Focus = "GENERAL HEALTH"
  (Multivitamins ARE general health)
  
- ELSE IF Health Focus = "GENERAL HEALTH" → "HEALTH FOCUS NON-SPECIFIC"
  (Non-multivitamin products shouldn't have "general health", be more specific)

Example 1:
```
Product: "Daily Multivitamin for Adults"
Category: "COMBINED MULTIVITAMINS"
Health Focus: (whatever model predicted) → "GENERAL HEALTH" (overridden)
```

Example 2:
```
Product: "Vitamin C 1000mg"
Category: "SINGLE VITAMINS"
Health Focus: "GENERAL HEALTH" → "HEALTH FOCUS NON-SPECIFIC" (too vague)
```


21.7 COMPLETE NA FLOW EXAMPLE
------------------------------

Case 1: Generic Product with Ingredient
----------------------------------------

Product: "Vitamin D3 5000 IU"

Step 1 (Script 7): Max probability = 0.25 < 0.30 → NA
Step 2 (Ingredient Lookup): VITAMIN D → "BONE HEALTH"
Step 3 (Old→New Mapping): Already correct
Step 4 (Vitamin D Override): Confirms "BONE HEALTH"
Result: "BONE HEALTH" ✅

Case 2: Unknown Product
------------------------

Product: "Super Green Formula Advanced"

Step 1 (Script 7): Max probability = 0.28 < 0.30 → NA
Step 2 (Ingredient Lookup): UNKNOWN → No match → Still NA
Step 3 (Default NA): "HEALTH FOCUS - NON SPECIFIC"
Step 4 (Low Confidence Rules): No keywords match
Result: "HEALTH FOCUS - NON SPECIFIC"

Case 3: Clear Prediction Overridden
------------------------------------

Product: "Glucosamine with Collagen for Beauty Hair Skin Nails"

Step 1 (Script 7): Predicts "JOINT HEALTH" (0.75)
Step 2-3: No changes
Step 4 (Keyword Rules): 
  - Current = "JOINT HEALTH"
  - Contains "COLLAGEN" ✓
  - Contains "BEAUTY" ✓
  → Override to "BEAUTY"
Result: "BEAUTY" ✅


================================================================================
SECTION 22: STATE AFTER SCRIPT 7 + BUSINESS RULES
================================================================================

At this point, each product has:
✅ RetailerSku
✅ Title
✅ Brand
✅ Primary ingredient (Script 1)
✅ other ing. 2, 3, 4... (Script 1)
✅ Category (Script 1 + business rules)
✅ Subcategory (Script 1 + business rules)
✅ Form (Script 2)
✅ Age (Script 3)
✅ Gender (Script 4)
✅ Count (Script 5 + business rules)
✅ Unit Of Measurement (Script 5)
✅ Size (Script 6 + business rules)
✅ Health Focus (Script 7 + extensive business rules)

Still Missing:
❌ Organic (post-processing)
❌ High Level Category (post-processing)

Next Steps:
- Organic detection (simple keyword search)
- High Level Category assignment (Category → HLC mapping)
- Final cleanup and export


================================================================================
SCRIPT 7 SUMMARY
================================================================================

What Script 7 Does:
1. ✅ Removes brand from title
2. ✅ Creates word count matrix (1000+ terms, no stemming)
3. ✅ Runs XGBoost ML model
4. ✅ Returns probabilities for 20 health focus categories
5. ✅ Applies 30% confidence threshold
6. ✅ Assigns NA if uncertain

Outputs:
- Health Focus (one of 20 categories, or NA)
- Full probability matrix (saved separately for analysis)

Business Rules (Most Extensive of All Scripts!):
1. NA fill from ingredient lookup (fallback)
2. Old → New HF taxonomy mapping (temporary workaround)
3. Vitamin D override (always BONE HEALTH)
4. 50+ keyword-based overrides (most rules!)
5. Gender-based correction (Men's/Women's conflicts)
6. Multivitamin → General Health

Method:
- XGBoost ML (more sophisticated than Random Forest)
- Confidence threshold (30%)
- Extensive business rule layer
- Ingredient-based fallback

Success Rate:
- ~75-80% from model alone
- ~85-90% after business rules
- Remaining ~10-15% marked as "HEALTH FOCUS NON-SPECIFIC"

Limitations:
- Model trained on old taxonomy (needs remapping)
- Heavy reliance on business rules for accuracy
- Some products genuinely have no clear health focus

Method Comparison:
- Script 1 (Ingredients): Rule-based lookup (960 lines)
- Scripts 2-4 (Form/Age/Gender): Random Forest ML
- Scripts 5-6 (Count/Size): REGEX pattern matching
- Script 7 (Health Focus): XGBoost ML + extensive business rules (longest processing!)


================================================================================
END OF SCRIPT 7 DOCUMENTATION
================================================================================


================================================================================
SECTION 23: POST-PROCESSING - ORGANIC DETECTION
================================================================================

Purpose: Determine if product is organic based on title keywords
Method: Simple keyword search (REGEX)
Location: FinalMerge.R Lines 333-346

Note: This happens BEFORE the taxonomy remapping and health focus business rules

    
23.1 ORGANIC DETECTION LOGIC
-----------------------------

```r
new_items$Organic = NA

for (i in 1:nrow(new_items)){
  if (grepl("INORGANIC", new_items$Title[i])){
    new_items$Organic[i] <- "NOT ORGANIC"
  } else if (grepl("ORGANIC", new_items$Title[i])) {
    new_items$Organic[i] <- "ORGANIC"
  } else {
    new_items$Organic[i] <- "NOT ORGANIC"
  }
}
```

Logic Priority:
1. IF title contains "INORGANIC" → "NOT ORGANIC"
2. ELSE IF title contains "ORGANIC" → "ORGANIC"
3. ELSE (no mention) → "NOT ORGANIC" (default assumption)

Why This Order?
- "INORGANIC" check first to handle edge case: "Made with organic and inorganic minerals"
- Without this, "organic" would match and incorrectly classify as ORGANIC


23.2 EXAMPLES
-------------

Example 1: Clearly Organic
```
Title: "ORGANIC TURMERIC POWDER USDA CERTIFIED"
Contains "ORGANIC" ✓
Result: Organic = "ORGANIC" ✅
```

Example 2: Explicitly Not Organic
```
Title: "VITAMIN D3 WITH INORGANIC MINERALS"
Contains "INORGANIC" ✓
Result: Organic = "NOT ORGANIC" ✅
```

Example 3: No Mention
```
Title: "GLUCOSAMINE 1500MG JOINT SUPPORT"
No "ORGANIC" or "INORGANIC"
Result: Organic = "NOT ORGANIC" (default) ✅
```

Example 4: Mixed Wording (Edge Case)
```
Title: "SUPPLEMENT WITH ORGANIC AND INORGANIC COMPOUNDS"
Contains "INORGANIC" ✓ (checked first!)
Result: Organic = "NOT ORGANIC" ✅
```


23.3 OUTPUT
-----------

Column: Organic
Values: "ORGANIC" or "NOT ORGANIC"

No NA values - everything gets assigned one of the two values.


23.4 ACCURACY AND LIMITATIONS
------------------------------

Accuracy: ~95%+

High Accuracy Because:
- Simple binary classification
- Keywords are very specific ("organic" is rarely used ambiguously in supplement titles)
- Default to "NOT ORGANIC" is safe assumption (most products aren't organic)

Limitations:
- Only checks title (not description or certifications)
- Can't distinguish between:
  - "Made with organic ingredients" (partially organic)
  - "100% organic" (fully organic)
  - Both classified as "ORGANIC"
- Doesn't verify actual organic certification
- Assumes no mention = not organic (may miss products that ARE organic but don't mention it)

Manual Review Rarely Needed:
- Very straightforward attribute
- Errors are uncommon


================================================================================
SECTION 24: POST-PROCESSING - HIGH LEVEL CATEGORY
================================================================================

Purpose: Group products into high-level business categories
Method: Simple Category-based mapping
Location: FinalMerge.R Lines 654-673

Note: This happens AFTER all other processing is complete


24.1 HIGH LEVEL CATEGORY LOGIC
-------------------------------

```r
Cat_NP <- list(
  "ACTIVE NUTRITION"
)

for (i in 1:nrow(new_items)){
  if (new_items$Category[i] == "OTC" && !is.na(new_items$Category[i])){
    new_items$`High Level Category`[i] <- "OTC"
    
  } else if ((new_items$Category[i] == "REMOVE" && !is.na(new_items$Category[i])) || 
             is.na(new_items$Category[i])) {
    new_items$`High Level Category`[i] <- "REMOVE"
    
  } else {
    if(new_items$Category[i] %in% Cat_NP){ 
      new_items$`High Level Category`[i] <- "NON-PRIORITY VMS"
    } else { 
      new_items$`High Level Category`[i] <- "PRIORITY VMS"
    }
  }
}
```

Logic:
1. IF Category = "OTC" → High Level Category = "OTC"
2. ELSE IF Category = "REMOVE" OR Category = NA → High Level Category = "REMOVE"
3. ELSE IF Category = "ACTIVE NUTRITION" → High Level Category = "NON-PRIORITY VMS"
4. ELSE (all other categories) → High Level Category = "PRIORITY VMS"


24.2 THE THREE HIGH LEVEL CATEGORIES
-------------------------------------

1. **PRIORITY VMS** (Vitamins, Minerals, Supplements)
   - Most supplement categories
   - Core business focus
   - Examples: Single Vitamins, Joint Health, Digestive Health, Herbal Remedies, etc.

2. **NON-PRIORITY VMS**
   - ACTIVE NUTRITION category only
   - Sports nutrition, protein, meal replacements
   - Secondary business focus

3. **OTC** (Over-The-Counter)
   - Pharmaceutical products
   - Not supplements
   - Example: Pain relievers, cough medicine, etc.

4. **REMOVE**
   - Products that should be filtered out
   - Non-supplement items
   - Invalid/error records


24.3 EXAMPLES
-------------

Example 1: Priority VMS
```
Category: "JOINT HEALTH"
Cat_NP list: ["ACTIVE NUTRITION"]
Category NOT in Cat_NP ✓
Result: High Level Category = "PRIORITY VMS" ✅
```

Example 2: Non-Priority VMS
```
Category: "ACTIVE NUTRITION"
Cat_NP list: ["ACTIVE NUTRITION"]
Category IN Cat_NP ✓
Result: High Level Category = "NON-PRIORITY VMS" ✅
```

Example 3: OTC
```
Category: "OTC"
First condition matches ✓
Result: High Level Category = "OTC" ✅
```

Example 4: Remove
```
Category: "REMOVE"
Second condition matches ✓
Result: High Level Category = "REMOVE" ✅
```

Example 5: Missing Category
```
Category: NA
Second condition matches ✓
Result: High Level Category = "REMOVE" ✅
```


24.4 PURPOSE AND BUSINESS USE
------------------------------

Why High Level Category Exists:
- Business needs to track product mix at high level
- Too many detailed categories for executive reporting
- Group similar products for analysis
- Prioritize inventory/marketing by category importance

Business Decisions Based on HLC:
- PRIORITY VMS: Core product line, most resources
- NON-PRIORITY VMS: Secondary focus, different marketing
- OTC: Different regulatory requirements, separate handling
- REMOVE: Exclude from reports, don't process further


24.5 OUTPUT
-----------

Column: High Level Category
Values: "PRIORITY VMS", "NON-PRIORITY VMS", "OTC", or "REMOVE"

No NA values - everything gets assigned one of the four values.


================================================================================
SECTION 25: FINAL CLEANUP AND OUTPUT
================================================================================

Purpose: Final data quality checks and export
Location: FinalMerge.R Lines 678-708


25.1 PRINT VALIDATION CHECKS
-----------------------------

```r
# Print visual checks
print(table(new_items$Category))
print(table(new_items$Subcategory))
print(table(new_items$'Functional Ingredient'))
print(table(new_items$`Health Focus`))
print(table(new_items$`High Level Category`))
```

Purpose: Output frequency tables for manual review
- Spot check for unusual distributions
- Identify potential errors
- Verify business rules executed correctly


25.2 HANDLE REMAINING NAs
--------------------------

```r
new_items$`Functional Ingredient`[is.na(new_items$`Functional Ingredient`)] <- "UNKNOWN"
```

Default any remaining NA functional ingredients to "UNKNOWN"


25.3 REMOVE TEMPORARY COLUMNS
------------------------------

```r
# Drop temporary columns
new_items <- new_items[, -which(names(new_items) %in% c("New.Focus", "key"))]
```

Remove columns used during processing:
- "New.Focus": Used in NA health focus fill
- "key": Used in taxonomy remapping (Category-Subcategory pair)


25.4 REORDER COLUMNS
--------------------

```r
new_items_reordered <- new_items %>%
  select(`Functional Ingredient`, RetailerSku, 
         Age, "Count", "Unit Of Measurement",
         Form, Category, Subcategory, Gender, `Health Focus`, 
         Title, Brand, Size, Organic, `High Level Category`)
```

Final column order for output file:
1. Functional Ingredient
2. RetailerSku
3. Age
4. Count
5. Unit Of Measurement
6. Form
7. Category
8. Subcategory
9. Gender
10. Health Focus
11. Title
12. Brand
13. Size
14. Organic
15. High Level Category


25.5 WRITE OUTPUT FILE
----------------------

```r
write.csv(new_items_reordered, outputfilename, row.names=F, fileEncoding="UTF-8")
```

Output:
- CSV format
- UTF-8 encoding (handles special characters)
- No row names
- Filename specified at script start


================================================================================
SECTION 26: COMPLETE END-TO-END FLOW SUMMARY
================================================================================

FINAL STATE - ALL COLUMNS POPULATED:
✅ RetailerSku (input)
✅ Title (input)
✅ Brand (input)
✅ Functional Ingredient (Script 1)
✅ Category (Script 1 → Business Rules → Taxonomy Remap)
✅ Subcategory (Script 1 → Business Rules → Taxonomy Remap)
✅ Form (Script 2)
✅ Age (Script 3)
✅ Gender (Script 4)
✅ Count (Script 5 + Pack Size QC)
✅ Unit Of Measurement (Script 5)
✅ Size (Script 6 + Pack Size QC)
✅ Health Focus (Script 7 + Extensive Business Rules → Taxonomy Remap)
✅ Organic (Post-Processing)
✅ High Level Category (Post-Processing)


COMPLETE PROCESSING SEQUENCE:

1. INPUT: Raw Amazon data (RetailerSku, Title, Brand)

2. SCRIPT 1 - Functional Ingredient Detection (Rule-based, 960 lines)
   → Outputs: Ingredient, Category, Subcategory

3. BUSINESS RULES AFTER SCRIPT 1
   → Refine Category/Subcategory based on ingredient patterns

4. SCRIPT 2 - Form Coding (Random Forest ML)
   → Outputs: Form

5. BUSINESS RULES AFTER SCRIPT 2
   → Protein form split, Hydration detection

6. SCRIPT 3 - Age Coding (Random Forest ML)
   → Outputs: Age

7. SCRIPT 4 - Gender Coding (Random Forest ML)
   → Outputs: Gender

8. BUSINESS RULES AFTER SCRIPTS 3 & 4
   → Multivitamin subcategory refinement (uses Age + Gender)

9. SCRIPT 5 - Count Size Coding (REGEX)
   → Outputs: Count, Unit Of Measurement

10. SCRIPT 6 - Pack Size Coding (REGEX)
    → Outputs: Size

11. BUSINESS RULE AFTER SCRIPTS 5 & 6
    → Pack Size/Count QC swap (if Size ≥ 20)

12. MERGE ALL OUTPUTS
    → Combine all script outputs by RetailerSku

13. POST-PROCESSING - ORGANIC DETECTION (REGEX)
    → Outputs: Organic

14. TAXONOMY REMAPPING (Lookup-based)
    → Remap OLD → NEW taxonomy for: Health Focus, Category, Subcategory

15. SCRIPT 7 - Health Focus Coding (XGBoost ML)
    → Outputs: Health Focus (with probabilities)

16. BUSINESS RULES AFTER SCRIPT 7 (Extensive!)
    → NA fill from ingredient lookup
    → Taxonomy remapping (OLD → NEW)
    → Vitamin D override
    → 50+ keyword-based overrides
    → Gender-based correction
    → Multivitamin → General Health

17. POST-PROCESSING - HIGH LEVEL CATEGORY (Mapping)
    → Outputs: High Level Category

18. FINAL CLEANUP
    → Handle remaining NAs
    → Remove temporary columns
    → Reorder columns
    → Write output CSV


TOTAL COLUMNS OUTPUT: 15 columns
TOTAL SCRIPTS: 7 main scripts + extensive business rules
TOTAL LINES OF CODE: ~1500+ lines (including business rules)
PROCESSING TIME: Varies by dataset size (minutes to hours for large datasets)


================================================================================
END OF COMPLETE R SYSTEM DOCUMENTATION
================================================================================


================================================================================
SECTION 27: MANUAL POST-PROCESSING WORKFLOW
================================================================================

After the R script completes, analysts perform extensive MANUAL review and corrections.
This is documented in "Amazon Coding Steps.docx"

Note: This is the MOST TIME-CONSUMING part of the process!


27.1 INPUT TO MANUAL PROCESS
-----------------------------

R Script Output File (CSV with 15 columns):
1. Functional Ingredient
2. RetailerSku
3. Age
4. Count
5. Unit Of Measurement
6. Form
7. Category
8. Subcategory
9. Gender
10. Health Focus
11. Title
12. Brand
13. Size
14. Organic
15. High Level Category


27.2 MANUAL CORRECTION STEPS
-----------------------------

Step 1: FIX CATEGORY = NA (Most Time-Consuming!)
-------------------------------------------------

Problem: Some items couldn't be categorized by the R script (NW Category = NA)

Important: The "Category" in R output is NATURE'S WAY category, not Amazon category!

Process:
A. Filter R output for items where Category = NA (Nature's Way category couldn't be assigned)

B. Cross-reference with ORIGINAL INPUT FILE to see Amazon's categories
   - The input file has: "Source Category Trx" and "Source Subcategory Trx" (Amazon/Stackline categories)
   - Match by RetailerSku/ASIN between R output and input file

C. Use Amazon's Source Category/Subcategory to identify potential VMS (supplement) items
   Look for items in these Amazon categories:
   - Cough & Cold
   - Digestion & Nausea
   - Energy Supplements
   - Herbal Supplements
   - Intimate Health
   - Multivitamins
   - Pain & Fever Medicine
   - Protein
   - Single Vitamins
   - Sleep & Snoring
   - Supplements
   - Weight Gain & Loss Supplements
   - Women's Health

D. Manually look up ASINs on Stackline/Amazon website (MOST TIME-CONSUMING!)
   - Check actual product page
   - Verify it's a dietary supplement
   - Identify ingredients if not obvious

E. Determine if item is a supplement
   
F. If YES: Assign proper NW Category and update High Level Category from REMOVE to PRIORITY VMS or NON-PRIORITY VMS

G. If NO: Leave as Category = NA (will be marked as REMOVE)

Example Workflow:
```
Step 1: R Output shows:
  RetailerSku: B001ABC123
  Category: NA (R script couldn't classify)
  Title: "Super Health Formula Advanced"

Step 2: Look up in ORIGINAL INPUT FILE:
  ASIN: B001ABC123
  Source Category Trx: "Herbal Supplements"
  Source Subcategory Trx: "Multi-Herb Formulas"

Step 3: Amazon category suggests it's a supplement!

Step 4: Manually look up on Amazon:
  Product page shows: "Contains Turmeric, Ginger, Ashwagandha"

Step 5: Analyst assigns:
  Category: "HERBAL REMEDIES"
  Subcategory: "FORMULAS"
  Functional Ingredient: "TURMERIC" (primary)
  High Level Category: "PRIORITY VMS"
```

Why Category = NA Happens:
- Title too vague for ingredient detection (Script 1 failed)
- No-space titles ("TurmericGingerAshwagandha")
- New/uncommon ingredients not in lookup tables
- Non-standard product descriptions
- Genuinely not a supplement (needs manual removal)


Step 2: REMOVE NON-SUPPLEMENT ITEMS
------------------------------------

Problem: Some non-supplement items get through initial filtering

Process:
A. Filter for these keywords in Title/Description:
   - Jewelry
   - Gemstones
   - Body Wash
   - Facial Masks
   - Books
   - Test Kits
   - Shirts
   - Essential Oils
   - Shampoo
   - Perfume
   - Machine
   - Grooming Kit
   - Cleanser
   - Clean Gainer (protein bar brand, not supplement)
   - DVD
   - Banana Drops (not a supplement)
   - Key Chain
   - Lotion

B. Mark these items: Category = "REMOVE", High Level Category = "REMOVE"

Example:
```
Product: "Aromatherapy Essential Oil Set"
R Script: Category = "HERBAL REMEDIES" (incorrectly classified)
Contains: "Essential Oils"
Manual Action: Category = "REMOVE", High Level Category = "REMOVE"
```


Step 3: FIX FORM = UNKNOWN/OTHER
---------------------------------

Problem: R script couldn't determine product form

Process:
A. Filter for Form = "UNKNOWN" or Form = "OTHER"
B. Look at Description for form keywords:
   - Gummy
   - Capsule
   - Tablet
   - Liquid
   - Powder
   - Softgel
   - Tincture
   - Drinkmix → Assign as "POWDER"
   - Ready to Drink → Assign as "LIQUID"

C. Manually assign correct Form

Common Issue: Titles without spaces
```
Product: "GlucosamineChondroitin120Capsules"
R Script: Form = "UNKNOWN" (couldn't tokenize "120Capsules")
Analyst sees: "Capsules" in the text
Manual Action: Form = "CAPSULE"
```


Step 4: FIX FUNCTIONAL INGREDIENT = UNKNOWN
--------------------------------------------

Problem: R script couldn't identify the ingredient

Process:
A. Filter for Functional Ingredient = "UNKNOWN"
B. Look at Description for ingredient keywords
C. Manually assign correct ingredient

Common Issue: Titles without spaces
```
Product: "VitaminD35000IUSoftgels"
R Script: Functional Ingredient = "UNKNOWN" (couldn't tokenize "VitaminD3")
Analyst sees: "VitaminD3" → "Vitamin D3"
Manual Action: Functional Ingredient = "VITAMIN D"
```

Why No-Space Titles Are Common:
- Amazon sellers copy-paste incorrectly
- Automated listing tools strip spaces
- Data entry errors
- Non-standard formatting

Typical Volume:
- 5-10% of items have Functional Ingredient = UNKNOWN
- Of those, 50-70% are due to no-space titles
- Rest are genuinely ambiguous products


Step 5: FIX HEALTH FOCUS = NON-SPECIFIC
----------------------------------------

Problem: R script couldn't determine specific health focus

Process:
A. Filter for Health Focus = "HEALTH FOCUS NON-SPECIFIC"
B. Review product title and category
C. Assign specific health focus based on:
   - Primary ingredient (e.g., Glucosamine → JOINT HEALTH)
   - Category (e.g., Digestive Health category → DIGESTIVE HEALTH)
   - Keywords in title (e.g., "for sleep" → SLEEP)

D. Special Rule: Ensure all items with:
   - Health Focus = "GENERAL HEALTH" have Category = "COMBINED MULTIVITAMINS"
   - Category = "COMBINED MULTIVITAMINS" have Health Focus = "GENERAL HEALTH"
   - If mismatch, correct one or the other


Step 6: VERIFY AND CORRECT PACK SIZE
-------------------------------------

Problem: Default value is 1, but some products have different pack sizes

Process:
A. Review products where title mentions pack size
B. Verify Size column matches title
C. Correct if needed

Example:
```
Product: "Vitamin D 5000 IU (3-Pack)"
R Script: Size = 1 (default)
Manual Action: Size = 3
```


27.3 ADDITIONAL COLUMNS ADDED MANUALLY
---------------------------------------

The following columns are added during manual post-processing:

Column 1: UPC
-------------
Source: External product databases, manufacturer websites
Process: Manually looked up for each product
Purpose: Product identification, inventory tracking
Added for: All products

Column 2: NW Sub Brand 1, 2, 3
------------------------------
Source: Internal Nature's Way brand classification
Process: Manually assigned for Nature's Way and Integrative Therapeutics products
Purpose: Sub-brand tracking (e.g., "Alive!", "Completia", "Fortify")
Added for: Only Nature's Way and Integrative Therapeutics products
Example:
```
Brand: Nature's Way
Sub Brand 1: Alive!
Sub Brand 2: Multivitamin
Sub Brand 3: (empty)
```

Column 3: Potency
-----------------
Source: Extracted from Title/Description
Process: Manually extracted and standardized
Purpose: Track dosage strength for analysis
Added for: Products where potency is relevant
Example:
```
Title: "Vitamin D3 5000 IU"
Potency: "5000 IU"

Title: "Fish Oil 1000mg"
Potency: "1000mg"
```

Note: R script does NOT extract potency - this is manual!

Column 4: COMPANY
-----------------
Source: Product brand mapping
Process: Manually assigned or from data source
Purpose: Track manufacturer/parent company
Added for: All products
Example:
```
Brand: "Nature Made"
Company: "Pharmavite"
```

Column 5: NW_UPC
----------------
Source: Internal Nature's Way systems
Process: Manually looked up in NW database
Purpose: Cross-reference with internal inventory
Added for: Only Nature's Way and Integrative Therapeutics products

Column 6: Spare1, Spare2, Spare3, Spare4, Spare5
-------------------------------------------------
Source: Not used
Purpose: Placeholder columns for future data needs
Status: Empty


27.4 COLUMN NAME CHANGES
-------------------------

During manual post-processing, some columns are renamed:

R Script Output → Master Item File:
- Title → Description
- Functional Ingredient → FUNCTIONAL INGREDIENT
- Category → NW Category
- Subcategory → NW Subcategory
- Form → FORM
- Age → AGE
- Gender → GENDER
- Health Focus → HEALTH FOCUS
- Size → SIZE (but becomes "Pack Count" in some versions)
- Count → (stays Count, but may be combined with Unit)
- Unit Of Measurement → Unit of Measure
- Organic → Organic
- High Level Category → HIGH LEVEL CATEGORY


27.5 FINAL MASTER ITEM FILE STRUCTURE (26 columns)
---------------------------------------------------

1. UPC (manual)
2. Description (renamed from Title)
3. Brand (from R script)
4. NW Category (renamed from Category)
5. NW Subcategory (renamed from Subcategory)
6. NW Sub Brand 1 (manual)
7. NW Sub Brand 2 (manual)
8. NW Sub Brand 3 (manual)
9. Potency (manual)
10. FORM (from R script)
11. AGE (from R script)
12. GENDER (from R script)
13. COMPANY (manual)
14. FUNCTIONAL INGREDIENT (from R script)
15. HEALTH FOCUS (from R script)
16. SIZE (from R script)
17. HIGH LEVEL CATEGORY (from R script)
18. NW_UPC (manual)
19. Unit of Measure (from R script)
20. Pack Count (from R script Size)
21. Organic (from R script)
22. Spare1 (empty)
23. Spare2 (empty)
24. Spare3 (empty)
25. Spare4 (empty)
26. Spare5 (empty)



27.7 QUALITY CHECKS
-------------------

Before finalizing, analysts verify:
1. No items with Category = NA unless intentionally REMOVE
2. All GENERAL HEALTH = COMBINED MULTIVITAMINS (and vice versa)
3. Form, Ingredient, Health Focus have no UNKNOWN values (or documented why)
4. Pack Size makes sense (no Size = 60 when it should be Count = 60)
5. All Nature's Way items have Sub Brands and NW_UPC populated
6. No non-supplement items (jewelry, books, etc.) remain


27.8 WORKFLOW SUMMARY
---------------------

```
R Script Output (CSV, 15 columns)
    ↓
Step 1: Import to working spreadsheet
    ↓
Step 2: Fix Category NA (manual lookup)
    ↓
Step 3: Remove non-supplements
    ↓
Step 4: Fix Form = UNKNOWN
    ↓
Step 5: Fix Ingredient = UNKNOWN
    ↓
Step 6: Fix Health Focus = NON-SPECIFIC
    ↓
Step 7: Verify Pack Size
    ↓
Step 8: Add UPC
    ↓
Step 9: Add Sub Brands (NW/IT only)
    ↓
Step 10: Add Potency
    ↓
Step 11: Add Company
    ↓
Step 12: Add NW_UPC (NW/IT only)
    ↓
Step 13: Rename columns
    ↓
Step 14: Quality checks
    ↓
Master Item File (CSV/Excel, 26 columns)
```


================================================================================
END OF MANUAL POST-PROCESSING DOCUMENTATION
================================================================================


================================================================================
SECTION 28: COMPLETE END-TO-END PROCESS SUMMARY
================================================================================

PHASE 1: DATA PREPARATION
--------------------------
Input: Raw Amazon data from Stackline
- ASIN/UPC Key
- MI: Brand
- MI: Description (product title)
- Source Category Trx
- Source Subcategory Trx
- Dollars in USD

PHASE 2: AUTOMATED R SCRIPT PROCESSING (5-30 minutes)
------------------------------------------------------
FinalMerge.R orchestrates:
1. Load and prepare input data
2. Run 7 coding scripts sequentially:
   - Script 1: Functional Ingredient (Rule-based, 960 lines)
   - Script 2: Form (Random Forest ML)
   - Script 3: Age (Random Forest ML)
   - Script 4: Gender (Random Forest ML)
   - Script 5: Count/Unit (REGEX)
   - Script 6: Size (REGEX)
   - Script 7: Health Focus (XGBoost ML)
3. Merge all outputs by RetailerSku
4. Apply extensive business rules
5. Output CSV with 15 columns

Success Rate: 85-95% of items fully coded

PHASE 3: MANUAL POST-PROCESSING (1-3 days depending on dataset)
----------------------------------------------------------------
Analysts manually:
1. Fix Category = NA (most time-consuming)
2. Remove non-supplement items
3. Fix Form = UNKNOWN
4. Fix Functional Ingredient = UNKNOWN
5. Fix Health Focus = NON-SPECIFIC
6. Verify Pack Size
7. Add 11 additional columns (UPC, Sub Brands, Potency, etc.)
8. Rename columns to match Master Item format
9. Quality checks

PHASE 4: FINAL OUTPUT
---------------------
Master Item File with 26 columns
Ready for:
- A4E system import
- Business analysis
- Sales reporting
- Inventory management


TOTAL TIME: 1-4 days depending on dataset size
- Automated: 5-30 minutes
- Manual: 1-3 days


================================================================================
END OF COMPLETE PROCESS DOCUMENTATION
================================================================================


================================================================================
QUICK REFERENCE GUIDE
================================================================================

COLUMN FLOW SUMMARY
-------------------

INPUT → R SCRIPT → MANUAL → MASTER ITEM FILE
------   ---------   ------   ----------------

1. ASIN/UPC Key → RetailerSku → (manual UPC lookup) → UPC
2. MI: Description → Title → (renamed) → Description
3. MI: Brand → Brand → Brand → Brand
4. Source Subcategory Trx → Subcategory1 → (used for filtering) → (not in output)
5. (Script 1) → Functional Ingredient → (manual fixes) → FUNCTIONAL INGREDIENT
6. (Script 1) → Category → (manual fixes) → NW Category
7. (Script 1) → Subcategory → (manual fixes) → NW Subcategory
8. (Script 2) → Form → (manual fixes) → FORM
9. (Script 3) → Age → Age → AGE
10. (Script 4) → Gender → Gender → GENDER
11. (Script 5) → Count → Count → (combined with Unit)
12. (Script 5) → Unit Of Measurement → Unit → Unit of Measure
13. (Script 6) → Size → Size → SIZE / Pack Count
14. (Script 7) → Health Focus → (manual fixes) → HEALTH FOCUS
15. (Post-process) → Organic → Organic → Organic
16. (Post-process) → High Level Category → (manual fixes) → HIGH LEVEL CATEGORY
17. (Manual) → → → NW Sub Brand 1, 2, 3
18. (Manual) → → → Potency
19. (Manual) → → → COMPANY
20. (Manual) → → → NW_UPC
21. (Manual) → → → Spare1-5


SCRIPT EXECUTION ORDER
----------------------

1. FI_CAT_Testing.R       → Functional Ingredient, Category, Subcategory
2. Form Coding Final.R    → Form
3. Age Coding Final.R     → Age
4. Gender Coding Final.r  → Gender
5. Count Size Coding.R    → Count, Unit Of Measurement
6. Pack Size Final.R      → Size
7. HF_JF1.R              → Health Focus

Then: Business Rules → Post-Processing → Manual Review → Master Item


LOOKUP TABLE PRIORITY
---------------------

For Category/Subcategory:
1. Amazon Subcategory (NA_Test_for_FI.xlsx) → REMOVE if non-supplement
2. Amazon Subcategory → REMAP (fallback values)
3. Ingredient Lookup (TextReplaceingredient_Final.xlsx) → OVERRIDES REMAP
4. Herb Logic (herb_task.xlsx) → SINGLES vs FORMULAS
5. Business Rules → Protein form split, multivitamin refinement
6. Taxonomy Remapping (MI Lookup.csv) → OLD to NEW names
7. Manual Review → Fix Category = NA


ML MODELS USED
--------------

Random Forest Models:
- Form (42 tokens)
- Age (22 tokens)
- Gender (6 tokens)

XGBoost Model:
- Health Focus (1000+ word features, 20 categories, 30% confidence threshold)

REGEX Patterns:
- Count/Unit (complex multi-stage pattern matching)
- Pack Size (simpler pattern matching)


MANUAL REVIEW REQUIREMENTS
---------------------------

High Priority (MUST review):
- Category = NA
- Form = UNKNOWN
- Functional Ingredient = UNKNOWN
- Non-supplement items

Medium Priority (SHOULD review):
- Health Focus = NON-SPECIFIC
- Pack Size verification
- Products with no-space titles

Low Priority (OPTIONAL review):
- Age/Gender predictions
- Count/Unit extraction
- Organic detection



KEY FILES LOCATIONS
-------------------

Input Data:
  /Data/Inputs/*.csv

R Scripts:
  /ModelScripts/*.R
  /FinalMerge.R (orchestrator)

Lookup Tables:
  /Data/TextReplaceingredient_Final.xlsx (ingredients)
  /Data/NA_Test_for_FI.xlsx (Amazon subcategory filtering)
  /Data/herb_task.xlsx (herb list)
  /Data/hf_lookup.csv (ingredient → health focus)
  /Data/MI Lookup.csv (old → new taxonomy)

ML Models:
  /FinalModels/AgeModel_Final.rda
  /FinalModels/FormModel_Final2.rda
  /FinalModels/GenderModel_Final.rda
  /FinalModels/xgb_111021_1.model

Output:
  /Outputs/*.csv (15 columns)
  Master Item File (26 columns, after manual work)


COMMON ISSUES AND SOLUTIONS
----------------------------

Issue: Category = NA
Solution: Look up Amazon Source Category/Subcategory in original input,
          manually verify on Amazon, assign correct NW Category

Issue: Form = UNKNOWN
Solution: Look for form keywords in title (gummy, capsule, tablet, etc.)

Issue: Functional Ingredient = UNKNOWN (especially no-space titles)
Solution: Manually parse title, identify ingredient, assign

Issue: Health Focus = NON-SPECIFIC
Solution: Use primary ingredient or category to infer specific health focus

Issue: Pack Size = 1 (default) but product is multi-pack
Solution: Check title for "3-pack", "twin pack", etc., correct Size value

Issue: Non-supplement items getting through
Solution: Filter for keywords (jewelry, books, lotion, etc.), mark as REMOVE



================================================================================
END OF DOCUMENTATION
================================================================================
